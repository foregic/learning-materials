# 操作系统

## 操作系统启动

bootset.s：将操作系统从磁盘上读进来

setup.s：获得了一些参数启动了保护模式

head.s：初始化了一些GDT表，初始化了一些页表

main.c：main的工作就是xx_init：内存、中断、设备、时钟、CPU等内容的初始化。一堆mem_init、trap_init、blk_dev_init、chr_dev_init、tty_init、time_init、sched_init初始化内存，初始化，获得硬件的参数完成对硬件的初始化，形成关键的数据结构，将来完成对操作系统的管理

~~~C
//init/main.c
void main(void)
{
	mem_init();
	trap_init();
	blk_dev_init();
	chr_dev_init();
	tty_init();
	time_init();
	sched_init();
	buffer_init();
	hd_init();
	floppy_init();
	sti();
	move_to_user_mode();
	if (!fork()){init();}
}
~~~

做了两件事：把操作系统读入内存；初始化

操作系统读入内存才能取指执行，才能完成功能

全局描述表（Global Descriptor Table，GDT）：

中断描述表（Interrupt Descriptor Table，IDT）

## 操作系统接口

操作系统接口：接口表现为函数调用，又由系统提供，所以称为系统调用。

系统调用

POSIX（Portable Operating System Interface of Unix）（IEEE制定的一个标准）

|   分类   |   posiX定义    |         描述         |
| :------: | :------------: | :------------------: |
| 任务管理 |      fork      |     创建一个进程     |
|          |     excel      |  运行一个可执行程序  |
|          | pthread_create |     创建一个线程     |
| 文件系统 |      open      |  打开一个文件或目录  |
|          |     EACCES     | 返回值，表示没有权限 |
|          | mode_t st_mode | 文件头结构：文件属性 |

## 系统调用的实现（System Call）

区分内核态和用户态，不能随意访问内存 

硬件检查DPL（目标特权级）≥CPL（当前特权级）才可以访问

0是内核态，3是用户态

当前程序执行在什么态？CS:IP是当前指令，所以用CS最低两位来表示

