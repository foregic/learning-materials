### 1引论

shell是UNIX的命令解释器

#### 1.6系统调用

### 2进程与线程

#### 2.1进程

计算机上所有可运行的软件，通常也包括操作系统被组织成若干顺序进程，简称进程。

##### 2.1.1进程模型

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。

每个程勋运行时，它的逻辑程序计数器被装入实际的程序计数器中，当该程序执行结束（或暂停执行）时，物理程序计数器被保存在内存中该进程的逻辑程序计数器中。

一个进程是某种类型的一个活动，有程序、输入、输出以及状态。如果一个程序运行了两边，则算做两个进程



##### 2.1.4进程的层次结构

##### 2.1.6进程的实现

为了实现进程模型，操作系统维护着一张表格（一个结构数组），即进程表（process table）。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、锁打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。

#### 2.2线程

每个进程由一个地址空间和一个控制线程

##### 2.2.1线程的使用

 需要多线程的主要原因是，在许多应用中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程设计模型会变得更加简单

##### 2.2.2经典的线程模型

进程模型基于两种独立的概念：资源分组处理与执行
同一个进程的线程共享进程的地址空间、全局变量、打开文件集、子进程、报警以及相关信号

第一列在一个进程中所有线程共享的内容，第二列每个线程自己的内容
进程之间有保护，线程之间是没有保护的，所有线程有完全一样的地址空间，共享同样的全局变量，每个线程都可以访问进程地址空间中的每一个内存地址，所以一个线程可以读、写甚至是清除另一个线程的堆栈。线程之间是没有保护的。原因：1.不可能；2.没必要。

| 每个进程中的内容   | 每个线程中的内容 | 线程中内容做哟并         |
| ------------------ | ---------------- | ------------------------ |
| 地址空间           | 程序计数器       | 记录接着要执行哪一条指令 |
| 全局变量           | 寄存器           | 保存线程当前的工作变量   |
| 打开文件           | 堆栈             | 记录执行历史             |
| 子进程             | 状态             |                          |
| 即将发生的报警     |                  |                          |
| 信号与信号处理程序 |                  |                          |
| 账户信息           |                  |                          |

资源管理单位是进程。
线程概念实现的是共享一组资源的多个线程的执行能力，以便这些线程可以为完成某一任务而共同工作

#### 2.3进程间通信

##### 2.3.1竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行时的精确时序，称为竞争条件。

##### 2.3.2临界区

凡是涉及到共享内存、共享文件以及共享任何资源的情况都会引发可能的读写覆盖错误。某种途径组织多个进程同时读写共享的数据。

需要互斥，即以某种手段确保当一个进程在使用一个共享变量或文件时，其他进程不能做同样的操作。

对共享内存进行访问的程序片段称为临界区域或临界区，如果使两个进程不能同时处于临界区，就能够避免竞争条件。

一个号的解决方案需要满足四个条件：

- 任何两个进程不能同时处于临界区
- 不应对CPU的速度和数量做任何假设
- 临界区外运行的进程不得阻塞其他进程
- 不得使进程无限期等待进入临界区

##### 2.3.4睡眠与唤醒



###### 生产者-消费者问题

两个进程共享一个公共的固定大小的缓冲区。

当缓冲区已满，则生产者睡眠，待消费者从缓冲区去除一个或多个数据项再唤醒生产者。同样，当消费者试图从缓冲区取数据而发现缓冲区为空时，消费者就睡眠，直到生产者向其中放入一些数据时再将其唤醒。

问题：消费者遇到count=0，唤醒生产者，唤醒信号丢失，可能导致消费者与生产者都睡眠

增加一个唤醒等待位：当一个wakeup信号发送给一个清醒的信号时，将该位置1，随后当该进程要睡眠时，如果唤醒等待位为1，则将该位清除，而该进程仍然保持清醒。唤醒等待位实际就是wakeup信号的一个小仓库。
从原则上来讲，并没有从根本上解决问题。

##### 2.3.5信号量

 

