## 进程间通信

基本概念

- 进程阻塞：当一个进程在执行某些操作的条件得不到满足时，就自动放弃CPU资源而进入休眠状态，以等待条件的满足。当操作条件满足时，系统就将控制权返还给该进程继续执行未完成的操作
- 共享资源：计算机的内存、存储器等资源是有限的，无法为每一个进程都分配一份单独的资源，所以系统就将这些资源在各个进程间协调使用，称为共享资源
- 锁定：当某个进程在使用共享资源，可能需要放置别的进程对该资源的使用

### 信号

系统用信号来通知一个或多个进程异步事件的发生。信号不但能从内核发往一个进程，也能从一个进程发往另一个进程。信号还提供了向UNIX系统进程传送软中断的简单方法。信号可以中断一个进程，无论它正在做什么工作。

信号本身不能直接携带信息，不能用作进程间的直接数据传送，而把信号作为非常情况的处理

可以用作在进程间传送

- SIGHUP：终止一个终端时，内核就把这一种信号发送给该终端所控制的所有进程。当进程组的首进程结束时，就会向该进程组的所有进程发送这种信号，可以保证一个用户退出使用时，其后台进程被终止，除非有其他方面的安排
- SIGINT：用户按了中断键（Ctrl+C），内核就向与该终端有关联的所有进程发送这种信号。提供了终止运行程序的简便方法
- SIGQUIT：用户按了退出键
- SIGILL：一个进程企图执行一条非法指令。SIGILL和SIGQUIT一样，形成非正常终止

信号处理：

Linux，signal.h提供了信号处理函数`int signal(int sig, __sighandler_t handler)`，第一个参数sig指明了所要处理的信号类型，可以取SIGKILL和SOGSTOP外的任何一种信号，参数handler描述了与信号关联的工作有以下三种取值

- 一个返回值为整数的函数地址：`int func(int sig)`，进程只要接收到类型为sig的信号，不管正在执行程序的哪一部分，就立即执行func()函数，当func()函数执行结束后，控制权返回进程被中断的那一点继续
- SIG_IGN：表示忽略信号
- SIG_DFL：表示恢复系统对信号的默认处理

```c++
signal(SIGINT, catch);	//将SIGINT信号与catch函数关联
int catch(int sig) {
    printf("Catch succeed!\n");
    return 1;
}
```

signal()用来处理其他进程发送的信号，kill()可以用来向其他进程发送信号，函数声明`int kill(pid_t pid, int sig);`，参数pid指定了信号发送的对象进程：可以使某个进程的进程标识符，也可以是以下值

- pid为0：发送到当前进程所造的进程组的所有进程
- pid为-1：信号按进程标识符从高到低的顺序发送给全部的进程
- pid小于-1：发送给标识符为pid绝对值的进程组里的所有进程

系统调用alarm()和pause()，alarm()建立一个进程的报警时钟，在时钟定时器到时的时候，用信号向程序报告。系统调用pause()能使调用的进程暂停执行，直至收到某种信号为止。

```c++
unsigned int alarm(unsigned int seconds);
int pause(void);	//返回始终是-1
```



### 4管道

管道就是将一个程序的输出和另外一个程序的输入连接起来的单项通道，如`#ls -l | more`，就建立了一个管道，获取ls -l的输出，再将其作为more命令的输入

当进程创建一个管道的时候，系统内核同时为该进程设立了一对文件句柄（一个流），一个用来从该管道获取数据，另一个则用来做向管道的输出

在Linux内核里，每个管道都是用一个inode节点来表示，看不到，只存在于系统的内核中。

fork()的子进程自动继承了父进程打开的文件句柄，利用继承的句柄，就可以实现父/子间的通信了

管道是单向的，因为没有提供锁定的保护机制，所以决定了数据的流动方向，然后在每个进程中关闭不需要的句柄

#### 系统调用建立管道

1. pipe()函数

   函数声明int pipe(int fd[2])，两个成员的整型数组，用于存放pipe()函数新建立的管道句柄，fd[0]用来从管道中读，fd[1]向管道中写

   返回值：0 成功 -1 错误

   因为父子进程同时拥有读写句柄，为了不必要的麻烦，在进程中务必要记住关闭不需要的句柄
   
1. dup()函数

   函数声明int dup(int oldfd)

1. dup2()函数

   函数声明int dup2(int oldfd, int newfd)

1. popen()/pclose()函数

   函数声明FILE *popen(char *command, char *type);

   popen()函数首先调用pipe()建立一个管道，然后用它fork()函数建立一个子进程，运行shell环境，然后在这个shell环境中运行"command"参数指定的程序，数据在管道中流向有“type”参数控制，只是用type参数中第一个字符。popen()打开的管道必须用pclose()关闭

   函数声明int pclose(FILE *stream)

   popen()，中“command”中使用任意合法的shell指令，包括重定向和管道如

   ```c++
   popen("ls ~roy", "r");
   popen("sort > /tmp/zixia", "w");
   popen("sort | uniq | more", "w");
   ```

管道注意事项

1. pipe()调用必须在fork之前
2. 及时关闭不需要的管道句柄
3. 使用dup()之前确定定向的目标是最小的文件句柄
4. 管道只能实现父子进程间的通信，如果两个进程之前没有fork()关系，就必须考虑其他进程通信方法

### 有名管道

有名管道在Linux系统中以一种特殊的设备文件的形式存在于文件系统中，不仅具有了管道的通信功能，也具有了 普通文件的特定（可以被多个进程共享，可以长期存在等等）

因为有名管道是存在于文件系统中的文件节点，所以可以用建立文件节点的方式建立有名管道。

```shell
$mknod sampleFIFO p
$mkfifo -m 0666 sampleFIFO
```

有名管道自动支持进程阻塞

有名管道必须同时有读/写两个进程端，如果一个进程试图向一个没有读入端进程的有名管道写入数据，一个SIGPIPE信号就会产生
管道操作的独立性，意味着不会因为任何原因而被中断，如果数据量超过一次传输上限时，就会被只能被分成多个独立读/写操作，这个操作就可能被别的进程的写操作大胆。也就是说别的进程把数据插入了该进程写入管道的数据序列从而造成了混乱。



### 文件和记录锁定

文件和记录锁定可分为咨询式锁定和强制锁定

- 咨询式锁定：某文件进行了咨询式锁定后，其他想要访问该文件的进程将被操作系统告知共享文件已经上了锁。但这不阻止它们对锁定文件的操作。
  - System V和BSD都提供了咨询式锁定
  - System V
    - #include<unistd.h>
    - int lockf(int fd, int function, long size);
    - fd是文件打开操作中获得的文件描述符
    - function可以取以下值
      - F_ULOCK：为一个先前锁定的区域解锁
      - F_LOCK：锁定一个区域
      - F_TLOCK：测试并锁定一个区域
      - F_TEST：测试一个区域是否已经上了锁
      - size指明了从文件当前位置开始的一段连续所动的区域长度，当size为0时，锁定记录将由当前位置一直扩展到文件尾
  - BSD
    - #include<sys/file.h>
    - int flock(int fd, int operation);
    - fd是一个打开文件的文件描述符
    - operation可以取以下值
      - LOCK_SH：共享锁
      - LOCK_EX：互斥锁
      - LOCK_UN：解锁
      - LOCK_NB：当文件已被锁定时不阻塞
- 强制锁定：当某共享文件被强制锁定后，操作系统将会对每个读写文件的请求进行核查，只有在确认该请求不会干扰上了锁的文件时，才允许对应的操作

### 消息队列

内核中保存的一个用来保存消息的队列，并不是简单的“先入先出”操作

msgtool

### 信号量

控制多个进程对共享资源使用的计数器。常被用作一种锁定保护机制，当某个进程在对资源进行操作时，组织其他进程对该资源的访问。System V中的信号量对象实际上是信号量的集合，可以包含多个信号量，控制多个共享资源

如果我要获得这个内存资源（加锁），则是 P(S) 操作，S 是信号量， P将信号量的值-1。
如果我要释放这个内存资源（解锁），则是 V(S) 操作，S 是信号量，V将信号量的值+1。

### 共享内存

被多个进程共享的内存。在各种进程间通信方法中是最快的，因为是将信息直接映射到内存中，省去了其他IPC方法的中间步骤



1. shmget 得到或者创建一个共享内存对象

   `int shmget(key_t key, size_t size, int shmflg) `

    key_t key 的值为一个IPC键值，可以通过IPC_PRIVATE 建立一个新的键值为0的共享对象 ，但这并不能保证与IPC对象的对应关系，不同进程之间需要同一个且不会重复的[IPC键值](https://www.zhihu.com/search?q=IPC键值&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A92678653})来完成通信，一般此参数使用[ftok函数](https://www.zhihu.com/search?q=ftok函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A92678653})来进行创建IPC键值。

   size_t size 是映射共享内存的大小，单位为字节 (Byte)，但在创建时这里的最小分配单位是一页，大致为4KB，当你超过4KB但是小于8KB时会主动分配两页，也就是不足一页(4KB)的按照一页计算。

   int shmflg 参数是需要注明的操作模式。

   - 0：取键值对应的共享内存，若此键值相应的共享内存不存在就报错。
   - IPC_CREAT：存在与键值对应的共享内存则返回标识符，若不存在则创建共享内存返回标识符。
   - IPC_CREAT|IPC_EXCL：不存在相应键值的共享内存则创建此共享内存，若存在则报错

   返回值：成功返回共享内存的标识符，失败返回-1。

2. shmat 获得共享内存的地址（与进程建立映射）

   `void *shmat(int shmid, const void *shmaddr, int shmflg)`

   int shmid 接收一个共享内存标识符参数，通常由 shmget 返回。

   const void *shmaddr 共享内存地址映射到进程哪块[内存地址](https://www.zhihu.com/search?q=内存地址&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A92678653})，若设 NULL 则让内核决定。

   int shmflg 选择操作模式，设 SHM_RDONLY 为只读共享内存，其他或0为可读写。

   返回值：成功返回映射完成的内存地址，失败返回-1。

3. shmdt 与进程断开映射关系

   `int shmdt(const void *shmaddr)`

   const void *shmaddr 在进程中用于映射内存地址的指针。

4. shmctl 管理共享内存（释放共享内存

   `int shmctl(int shmid, int cmd, struct shmid_ds *buf)`

   int shmid 接收一个共享内存标识符参数，通常由 shmget 返回。

   int cmd 是需要注明的操作模式。

   - IPC_STAT：获取共享内存状态，将共享内存的 shmid_ds 信息拷贝到 shmid_ds *buf 中。
   - IPC_SET：更改共享内存状态，将 shmid_ds *buf 所指内容拷贝到共享内存 shmid_ds 中。
   - IPC_RMID：删除释放这块共享内存。

   struct shmid_ds *buf 内存管理结构体，这个结构在 shm.h 中定义

   返回值：成功返回0，失败返回-1。

5. 实际使用：shmget -> shmat -> shmctl （创建 -> 映射 -> 销毁）。有重复映射同一个共享内存时，流程变为shmget -> (shmat -> shmdt) -> shmctl 。因为每次映射时都会新找一块空闲内存进行映射，所以需要shmdt断开映射

