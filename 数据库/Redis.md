Redis

### 2简单动态字符串SDS（simple dynamic string，SDS）

```c
struct sdshdr {
    int len;
    int free;
    char buf[];
};
```

SDS的API都是二进制安全的

### 3链表

```c
//adlist.h/listNode，链表节点
typedef struct listNode {
	struct listNode *prev;	//前驱节点
    struct listNode *next;	//后继节点
    void *value;			//节点值
}listNode;
//adlist.h/list，链表
typedef struct list {
    listNode *head;		//头结点
    listNode *tail;		//尾节点
    unsigned long len;	//链表长度
    void *(*dup)(void *ptr);	//节点值复制函数
    void (*free)(void *ptr);	//节点释放函数
    int	(*match)(void *ptr, void *key);	//节点值比较函数 
}list;
```

### 4字典

Redis的字典使用了哈希表作为底层实现，一个哈希表里面有多个哈希表节点，每个哈希表节点保存了字典中的一个键值对。

```c
typedef struct dictht {	//哈希表
    dictEntry **table;	//哈希表数组，每个元素都是一个指向dictEntry的指针
    unsigned long size;	//哈希表大小
    unsigned long sizemask;	//哈希表大小掩码，用于计算索引值，总是等于size-1
    //sizemask总是等于size-1，和size一起决定一个键应该被放到table数组的哪个索引上面。
    unsigned long used;	//该哈希表已有节点的数量
}dictht;

typedef struct dictEntry {
    void *key;	//键
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    }v;
    
    struct dictEntry *next;	//指向下一个哈希表节点
}dictEtry;

typedef struct dict {
    dictType *type;
    void *privadata;;
    dict *ht[2];
    int trehashidx;
}
```

###### 哈希表扩展与收缩

扩展操作条件：

- 服务器目前没有在执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1
- 服务器目前正在执行BGSAVE或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5
- 负载因子`load_factor = ht[0].used / ht[0].size`
- 负载因子不同，是因为执行BGSAVE或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都是采用写时复制技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子从而避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地结余内存
- 当负载因子小于0.1时，程序自动开始对哈希表执行收缩操作

#### 4.5渐进式rehash

1. 首先给ht[1]分配空间
2. 将rehashidx置0，表示rehash开始
3. 当rehashidx!=-1时，即rehash过程中，每次对字典执行添加、删除、查找、或者更新操作时，会将ht[0]在rehashidx索引上的所有键值对rehash到ht[1]上，rehashidx索引上的所有键值对rehash完成之后，rehashidx加1
4. 随着字典操作的不断进行，最终，ht[0]的所有键值对都会rehash到ht[1]，这时程序将rehashidx的值置-1，表示rehash过程完成，
5. 优点：
   1. 分而治之的手段，将rehash的过程分摊到对字典每个添加、删除、查找和更新的操作上，从而避免了集中式rehash而带来的庞大计算量。也不用专门设置个监视器监视字典
6. 在渐进式rehash过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash过程中，字典的删除、查找、更新等操作会在两个哈希表上进行。先在ht[0]找，没找到再在ht[1]里找。
7. 新添加的键值对一律保存到ht[1]中，ht[0]不再进行任何操作，保证了ht[0]的键值对数量只减不增，随着rehash过程最终变成空表

### 5跳跃表

Redis只在两个地方用到了跳跃表，一个是实现有序集合键，一个是在集群节点中用作内部数据结构

#### 5.1跳跃表的实现

```c
typedef struct zskiplistNode {
    struct zskiplistLevel {
        struct zskiplistNode *forward;//前进指针
        unsigned int span;	//跨度
    }level[];
    struct zskiplistNode *backward;	//后退指针
    double socre;	//分值
    robj *objl	//成员对象
} zskiplistNode;
```

1. 层：随机生成一个介于1~32之间的值作为level数组的大小，索引从0开始
2. 前进指针：每层都有一个指向表位方向的前进指针（level[i].forward属性），用于从表头向表尾访问节点
3. 层的跨度（level[i].span）：用于记录两个节点之间的距离。遍历操作只使用前进指针就可以完成，跨度实际上是用来计算排位的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来得到的结果就是目标节点在跳跃表中的排位
4. 后退指针（backward属性）：用于从表尾向表头方向访问节点：跟可以一次跳过多个节点的前进指针不同，每个节点只有一个后退指针，所以每次只能后退至前一个节点。
5. 分值和成员：
   - 分值（score）：是一个double类型的浮点数，跳跃表中所有节点都按分值从小到大来排序
   - 节点的成员对象（obj）：是一个指向字符串对象的指针，而字符串对象则保存着一个SDS值
   - 在同一个跳跃表中，每个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的：分值相同的节点将按照成员对象在字典序中的大小来进行排序。成员对象较小的节点会排在前面（更靠近表头的方向），而成员对象较大的节点会排在后面（表尾方向）



```c
typedef struct zskiplist {
	struct zskiplistNode *header, *tail;//表头节点和表尾节点
    unsigned long length;//表中头结点的数量
    int level;//表中层数最大的节点的层数
}zskiplist;
```

header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为O(1)。
通过使用length属性来记录节点的数量，程序可以在O(1)的复杂度内返回跳跃表的长度。
level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点层数量，表头节点的层高不计算在内

### 6整数集合(intset)

整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现

#### 6.1整数集合的实现

```c
typedef struct intset {
    uint32_t encoding;//编码方式
    uint32_t length;//集合包含的元素数量
    int8_t contents;//保存元素的数组
} intset;
```

contents数组是整数集合的底层实现：整数集合每个元素都是contents数组的一个数组项，各个项在数组中按值的大小从小到大有序排列，并且数组中不包含任何重复项。
length属性记录了整数集合包含的元素数量，也即是contents数组的长度。

虽然contents类型为int8_t，但是contents并不包含任何int8_t类型的值，contents数组真正的类型屈居于encoding属性的值

| encoding         |                                                              |
| ---------------- | ------------------------------------------------------------ |
| INTSET_ENC_INT16 | contents就是一个int16_t类型的数组，每个元素都是int16_t类型，大小范围-32768~32767 |
| INTSET_ENC_INT32 | contents是int32_t类型，范围-2147483648~2147483647            |
| INTSET_ENC_INT64 | contents是int64_t类型                                        |

#### 6.2升级

每当一个新元素被添加到整数集合里，并且新元素的类型比整数集合现有的所有元素类型都要长时，整数集合需要先进性升级，然后才能将新元素添加到整数集合里。

升级整数集合分三步：

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
- 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持地城数组的有序性质不变
- 将新元素添加到底层数组里面

添加新元素的复杂度O(N)

#### 6.3升级的好处

- 提升整数集合的灵活性
  - 整数集合自动升级底层数组来适应元素，所以可以随意将int16_t、int32_t、int64_t类型的值添加进整数集合
- 节约内存
  - 整数集合既可以让集合能同时保存三种不同类型的值，也可以确保升级操作只会在有需要的时候进行，尽量节省内存

#### 6.4降级

整数集合不支持降级操作，一旦进行了升级，编码就会一直保持升级后的状态

#### 6.5整数集合API

### 7压缩列表

压缩列表是列表建和哈希键的底层实现之一。当一个列表键只包含少量列表项时，并且每个列表项幺妹就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现

小整数值和短字符串

哈希键包含少量键值对，每个键值对的键和值要么就是小整数值，要么就是短字符串，Redis就会使用压缩列表来做哈希键的底层实现

#### 7.1压缩列表的构成


|         |          |       |                                                              |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配或者计算zlend位置时使用 |
| zltail  | uint32_t | 4字节 | 记录压缩列表表尾节点距离压缩列表起始地址有多少个字节偏移量，程序无须遍历整个压缩列表就能确定表尾节点的地址 |
| zllen   | uint16_t | 2字节 | 记录压缩列表包含的节点数量：当这个属性的值小于65535时，这个属性的值就是压缩列表包含节点的数量；当这个值等于65535时，节点的真实数量需要遍历整个压缩列表才能计算得出 |
| entryX  | 列表节点 | 不定  | 压缩列表包含的各个节点。节点的长度有节点保存的内容决定       |
| zlend   | uint8_t  | 1字节 | 特殊值0xFF(十进制255)用于标记压缩列表的末端                  |

#### 7.2压缩列表节点的构成

每个压缩列表节点都可以保存一个字节数组或者一个整数值。

- 字节数组：
  - 长度小于等于63(2^6-1)字节的字节数组
  - 长度小于等于16383(2^14-1)字节的字节数组
  - 长度小于等于4294967295(2^32-1)字节的字节数组
- 整数值：
  - 4位长，介于0至12之间的无符号整数
  - 1字节长的有符号整数
  - 3字节长的有符号整数
  - int16_t类型整数
  - int32_t类型整数
  - int64_t类型整数

每个压缩列表都由previous_entry_length、encoding、content三个部分组成

- previous_entry_length：

  - 记录了压缩列表中前一个节点的长度
  - previous_entry_length属性的长度可以是1字节或5字节
    - 如果前一节点的长度小于254字节，那么为1
    - 大于等于254字节，属性的长度为5字节第一字节未被设置为0xFE，之后四个字节用于保存前一个节点的长度
  - 通过地址计算可以实现从表尾向表头遍历

- encoding

  - 记录了节点的content属性所保存的数据的类型及长度

  - 1字节、2字节或5字节长

    - 值的最高位为00、01、10的是字节数组编码：表示节点的content属性保存着字节数组，数组的长度由编码除去最高位两位之后的其他位记录
    - 1字节长，最高位以11开头的整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录

  - |          |       |                                                              |
    | -------- | ----- | ------------------------------------------------------------ |
    | 11000000 | 1字节 | int16_t类型的整数                                            |
    | 11010000 | 1字节 | int32_t类型的整数                                            |
    | 11100000 | 1字节 | int64_t类型的整数                                            |
    | 11110000 | 1字节 | 24位有符号整数                                               |
    | 11111110 | 1字节 | 8位有符号整数                                                |
    | 1111xxxx | 1字节 | 没有相应的content属性，因为编码本身xxxx四位就保存了一个介于0-12的值 |

    

- content

  - 负责保存节点的值，节点值可以是一个字节数组或者整数值的长度由节点的encoding属性决定

#### 7.3连锁更新

因为连锁更新，在最坏情况下需要对压缩列表执行N次空间重新分配，每次空间分配最坏复杂度为O(N)，所以连锁更新的醉话复杂度为O(N2)

尽管最坏情况复杂度很高，实际情况下，造成性能问题几率很低，必须要恰好有连续的、长度介于250字节至253字节的节点
即使出现连锁更新，只要更新的节点数量不多就不会对性能造成影响

平均复杂度为O(N)

### 8对象

Redis基于五种对象构成数据库：

- 字符串对象
- 列表对象
- 哈希对象
- 集合对象
- 有序集合对象

好处：通过这五种不同类型的对象

1. 根据对象的类型来判断一个对象是否可以执行给定的命令
2. 针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率
3. 对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数实现了对象共享机制，这一机制在适当的条件下通过让多个数据库键共享一个对象来节约内存
4. Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启动了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除

#### 8.1对象的类型与编码

在数据库中创建键值对时，创建两个对象：键对象和值对象

| 类型         | 编码                      | 对象                                           |
| ------------ | ------------------------- | ---------------------------------------------- |
| REDIS_STRING | REDIS_ENCODING_INT        | 使用整数值实现的字符串对象                     |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | 使用embstr编码的简单动态字符串实现的字符串对象 |
| REDIS_STRING | REDIS_ENCODING_RAW        | 使用简单动态字符串实现的字符串对象             |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的列表对象                     |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 使用双端链表实现的列表对象                     |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的哈希对象                     |
| REDIS_HASH   | REDIS_ENCODING_HT         | 使用字典实现的哈希对象                         |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 使用整数集合实现的集合对象                     |
| REDIS_SET    | REDIS_ENCODING_HT         | 使用字典实现的集合对象                         |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 使用压缩列表实现的有序集合对象                 |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 使用跳跃表和字典实现的有序集合对象             |



##### 8.1.1类型

键总是一个字符串对象，称呼一个键为列表键时，是指键所对应的内容是列表对象

#### 8.2字符串对象

字符串对象的编码可以使int、raw、embstr

- 如果是整数值，可以用long表示，整数值保存在ptr属性里，同时将void*转换成long，编码设置为int
- 字符串值，字符串值的长度大于32，简单动态字符串保存，同时将编码设置为raw
- 字符串值，长度小于等于32，embstr编码的方式保存字符串值
  - 区别：raw会调用两次内存分配函数分别创建redisObject和sdshdr结构，rmbstr只调用一次内存分配函数分配一块连续的内存空间，空间中依次包含redisObject和sdshdr结构
  - 好处：
    - 只需调用一次内存分配函数
    - 只需调用一次内存释放函数
    - 所有数据都在一块连续的内存里，能够更好利用cache的优势

字符串编码的转换

- 保存的是一个整数值，某些操作使对象保存的不再是整数值，而是字符串，那么就会从int转换成raw
- Redis没有为embstr编写任何的修改程序（仅int和raw有），所以embstr是只读的，如果要对其进行修改，会先转成raw再进行修改，所以一个embstr编码对象修改过后总是raw编码

#### 8.3列表对象

编码：ziplist或者linkedlist

字符串对象是Redis唯一一种会被其他是四种类型对象嵌套的对象

编码转换：

- ziplist
  - 列表对象保存的所有字符串元素的长度都小于64字节
  - 列表对象保存的元素数量小于512个
- 不能满足以上两个条件的列表对象使用linkedlist编码
- 可以修改配置文件，修改两个数字



#### 8.4哈希对象

编码：ziplist或者hashtable

ziplist实现的哈希对象：

- 插入新的键值对时，先将保存了键的压缩列表节点推入到压缩列表表尾，再将保存了值的节点推入到压缩列表表尾
- 同一键值对象的两个节点总是紧凑在一起，键节点在前，值节点在后
- 先来的在头，后来的在尾

hashtable实现的哈希对象：

- 每个键值对都使用一个字典键值对来保存
- 每个键都是一个字符串对象，保存了键值对的键
- 每个值都是一个字符串对象，保存了键值对的值

编码转换：

- 所有键值的字符串长度都小于64字节
- 保存的键值对数量小于512
- 满足就是ziplis否则就是hashtable，可以修改配置文件，修改两个数字

#### 8.5集合对象

编码：intset或hashtable

intset

hashtable：

- 每个键都是字符串对象，字符串对象包含了一个集合元素
- 字典的值被设置为NULL

编码的转换：

- 所有元素都是整数值
- 保存的元素对象不超过512个
- 满足就是 intset，否则就是hastable

#### 8.6有序集合对象

编码：ziplist或者skiplist

ziplist：

- 第一个节点保存元素的成员（member）
- 第二个节点保存元素的分值（score）
- 压缩列表内的集合元素按分值从小到大排序，分值较小的元素被放置在靠近表头的方向，分值较大的元素被放置在靠近表尾的方向

skiplost编码的有序集合对象，使用zest结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表

```c++
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
} zset;
```

- zset结构中zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素
- 跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性保存了元素的分值。通过跳跃表，可以对有序集合进行范围型操作
- 跳跃表实现了对有序集合进行范围型操作
- dict字典为有序集合创建一个从成员到分值的映射
- 字典中的每个键值对保存了一个集合元素：字典的键保存了元素的成员，字典的值保存了元素的分值
- 字典实现了可以用O(1)复杂度查找给定成员的分值
- 虽然zset结构中，同时使用了跳跃表和字典保存有序集合元素，但两种数据结构都通过指针共享相同元素的成员和分值，不会产生任何 重复成员或者分值，也因此不会浪费额外的内存。

编码的转换:

- 有序集合保存的元素数量小于128个
- 所欲元素成员的长度都小于64字节
- 满足就是ziplist，否则就是skiplist
- 可以通过配置文件修改两个数字

#### 8.7类型检查与命令多态

一种对任何类型的键执行

- DEL、EXPIRE、RENAME、TYPE、OBJECT

一种对特定类型键执行

- SET、GET、APPEND、STRLEN只能对字符串键执行
- HDEL、HSET、HGET、HLEN只能对哈希键执行
- RPUSH、LPOP、LINSERT、LLEN只能对列表键执行
- SADD、SPOP、SINTER、SCARD只能对集合键执行
- ZADD、ZCARD、ZRANK、ZSCORE只能对有序集合键执行

检查RedisObject的type是否能执行所输入命令，可以就执行，不可以就返回错误

#### 8.8内存回收

引用计数技术实现内存回收机制：跟踪对象的引用计数信息，在适当地时候释放内存并进行内存回收

引用计数信息变化：

- 创建新对象，引用计数置1
- 被新程序使用，计数值加1
- 不再被程序使用，计数值减1
- 引用计数值为0，释放

#### 8.9对象共享

Redis中多个键共享一个值对象：

- 数据库键的指针指向一个现有的值对象
- 将被共享的值对象的引用计数加1
- 共享对象机制分厂节省内存，保存的相同值对象越多，对象共享机制就越节省内存
- 初始化时，会创建0-9999一万个字符串对象，可以修改配置文件修改数量

#### 8.10对象的空转时长

type、encoding、ptr、refcount，最后一为lru属性，记录了最后一次被命令程序访问的时间

当服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么服务器所占用的内存数超过了maxmemory所设置的上限时，空转时长较高的那部分键会优先被服务器释放掉

### 9数据库

#### 9.1服务器中的数据库

Redis服务器将所有数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDb结构，每个redisDb代表一个数据库，初始化时，会更具dbnum属性决定应该创建多少个数据库，由配置中database选项决定

#### 9.2切换数据库

服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，是一个指向redisDb结构的指针

通过select命令，使db指向不同的数据库，这就是select实现原理

#### 9.3数据库键空间

redisDb结构中的dict字典保存了所有键值对，键就是数据库的键，值就是数据库的值，键是一个字符串对象，值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象

所有对数据库键的操作，都是通过对字典中键指向的值对象进行操作，删除键是删除键和删除键所指的值对象

#### 9.4设置键生存的时间或过期时间

EXPIRE

EXPIREAT或者PEXPIREAT设置秒或者毫秒精度，设置过期时间，过期时间是一个UNIX时间戳



保存过期时间：

redisDb结构中的expires字典保存数据库中所有键的过期时间，称这个字典为过期字典

- 键是指针，指向键空间中的某个键对象，
- 值是long long类型的整数，保存了键所指向数据库键的过期时间，一个毫秒级精度的UNIX时间戳



### 10RDB持久化

### 11AOF持久化

### 12事件

### 13客户端

### 14服务器

### 15复制



PSYNC，完整重同步，都是发送RDB文件，再发送保存在缓冲区内的命令，让主从同步。部分重同步，主服务器将主服务器连接断开期间执行的写命令发送给从服务器，从服务器接收命令，就可以将数据更新至主服务器所处的状态。

### 16Sentinel

Sentinel（哨兵、哨岗）是Redis高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些服务器下属的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。



### 17集群

集群通过分片来进行数据共享，并提供复制和故障转移功能

集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息

#### 17.1节点

#### 17.2槽指派

Redis集群通过分片的方式保存数据库中的键值对：整个集群被分为16384个槽（slot），数据库中的每个键都属于这16384个槽的其中一个，每个节点可以处理0个或最多16384个槽

### 23慢查询日志

用于记录执行时间超过给定市场的命令请求，用户可以通过这个功能产生的日志来监视和优化查询进度

### 24监视器

MONITOR

### 缓存雪崩、缓存穿透、缓存击穿

缓存雪崩

- 缓存同一时间大面积失效，后面的请求权落到数据库上，造成数据库短时间内承受大量请求而崩掉
- 解决方案
  - 缓存数据的过期时间设置随机
  - 每个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存
  - 缓存预热
  - 互斥锁

缓存穿透

- Redis中没有的数据，导致请求落到数据库上，造成数据库承受压力过大
- 解决方案
  - 布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据	会被拦截掉
  - 接口层增加校验，用户鉴权校验，id做基础校验，id<=0的直接拦截
  - 从缓存读取不到的数据，在数据库中也没有读取到，可以设置key对应的value为null，缓存有效时间设短点

缓存击穿：

- 缓存中没有但数据库中有的数据，由于并发用户特别多，同时读换粗没读到数据，又同时到数据库取数据，引起数据库压力瞬间过大，造成过大压力，和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库
- 解决方案
  - 设置热点数据永不过期
  - 加互斥锁

### Redis持久化机制

- SAVE：会阻塞主进程
- BGSAVE：创建一个新的进程进行持久化

RDB

- 优点
  - 整个数据库包含一个dump.rdb
  - 容灾性好，方便备份
  - 性能最大化，fork出一个子进程来完成写操作
  - 数据集大时，比AOF启动效率高
- 缺点：
  - 数据安全性低，两次持久化之间发生故障会丢失数据
  - RDB是通过子进程完成持久化，因此当数据集较大时，可能会导致整个服务器停止服务几百毫秒

AOF

- 优点：
  - 数据安全
  - 通过追加的方式写文件，服务器宕机也不会损坏以及存在的内容
  - AOF重写模式，定期重写AOF文件放置AOF文件过大
- 缺点：
  - AOF文件比RDB大
  - 数据集大，启动速度慢
  - 运行效率没有RDB高

#### Redis主从同步机制

runid：每个redis节点启动都会生成唯一的id，每次Redis重启后，runid就会发生变化
offset：主从节点各自维护自己的赋值偏移量offset，当主节点有写入命令时，offset=offset+命令的字节长度，从节点在收到主节点发送的命令后，会增加自己的offset，并把自己的offset发送给主节点，主节点同时保存自己的offset和从节点的offset，通过offset来判断主从节点数据是否一致
repl_backlog_size：保存在主节点上的一个固定长度的先进先出队列，默认大小为1MB

全量复制：

- 主节点启动BGSAVE进行RDB持久化
- 主节点将RDB文件发送给从节点，从节点完成加载数据之前，写命令写入缓冲区
- 从节点清理本地数据并加载RDB，如果开启了AOF会重写AOF
- 从节点完成加载RDB，主节点将缓冲区内命令发送给从节点

部分复制：

- 复制偏移量 psync runid offset
- 复制积压缓冲区，当朱从节点offset差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制
  - 如果从节点保存的runid与主节点runid相同，说明之前同步过，主节点继续尝试使用部分复制
  - 如果不同，说明从节点断线前同步的Redis并不是当前主节点，只能进行全量复制

#### Redis单线程为什么这么快

原因：

- 纯内存操作
- 核心是基于非阻塞I/O多路复用程序
- 单线程避免了多线程频繁的上下文切换带来的性能问题

1. Redis基于内存进行操作
2. 没有线程上下文切换消耗
3. I/O多路复用技术监听多个Socket，根据socket上的事件类型选择对应的事件处理器来处理这个时间，可以实现高性能的网络通信模型，又可以跟内部其他单线程模块进行对接，保证了Redis内部线程模型的简单性
   - 文件事件处理器分为四个部分：多个socket、IO多路复用程序、文件事件分派器、事件处理器

#### Redis集群方案，解决单体故障问题

###### 哨兵模式（Sentinel），Redis集群

-  集群监控：负责监控Redis master和slave是否正常工作
- 消息通知：如果某个Redis实例发生故障，哨兵负责发送消息作为报警通知给管理员
- 故障转移：如果master节点发生故障，会选择一个slave作为master
- 配置中心：如果故障张毅发生了，会通知client客户端新的master

哨兵计划用于实现Redis集群的高可用性，本身也是分布式的，作为一个哨兵集群取运行

- 故障转移时，判断一个master是否宕机了，需要大部分哨兵都同意才行，涉及到分布式选举
- 即使部分哨兵挂掉了，哨兵集群仍能正常工作
- 哨兵通常要3个实例，保证自己的健壮性
- 哨兵+Redis主从部署架构，不保证数据零丢失，只能保证Redis集群高可用性

###### Redis sharding

采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key映射到特定的Redis节点

优点：非常检点，服务端Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，灵活性强
缺点：由于处理放到客户端，规模进一步扩大时不利于运维。不支持动态增删节点，服务端Redis集群拓扑结构有变化时，每个客户端都需要调整更新，连接不能共享，应用规模扩大时，资源浪费制约优化。

###### Redis Cluster

采用slot（槽）概念，一共分为16384个槽，将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行

- 通过哈希算法，将每个节点均分存储一定哈希槽区间的数据
- 每份数据片存储在多个互为主从的多节点上
- 数据先写入主节点，再同步到从节点（支持配置为阻塞同步）
- 同一分片多个节点间的数据不保持强一致性
- 读取数据时，当客户端操作的key没有分配在该节点上时，Redis会返回转向指令，指向正确的节点
- 扩容时需要把旧节点的数据迁移一部分到新节点

cluster架构中，每个Redis开放两个端口，比如一个6379，一个加1w，比如16379
16379用来进行节点间通信，记性故障检测、配置更新、故障转移授权。采用一种二进制协议**gossip**协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间

- 优点：
  - 无中心架构，支持动态扩容，对业务透明
  - 具备哨兵的监控和故障转移的能力
  - 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可，连接复用
  - 高性能，客户端直连Redis服务器，免去了proxy代理的损耗
- 缺点：
  - 运维很复杂，数据迁移需要人工干预
  - 只能使用0号数据库
  - 不支持批量操作（pipeline管道操作）
  - 分布式逻辑和存储模块耦合

#### Redis事务实现

- 事务
  - 事务开始：MULTI
  - 命令入队：命令放入队列，如果命令语法有问题，事务停止。语法没问题，执行起来有问题，剩下命令也执行完
  - 事务执行：EXEC
  - WATCH命令是一个乐观锁，监控一个或多个键，一旦有一个键被修改（或删除），之后的事务就不会执行，监控会一直持续到EXEC命令
  - MULTI（开启一个事务）、EXEC（执行事务快内的所有命令）、DSCARD（清空事务队列，放弃执行事务）、UNWATCH（取消watch对所有key的监控）
- A：没有回滚机制
- C：
- I：单线程，事务被同一个线程执行。watch命令，监控key
- D：

#### Redis过期键的删除策略

- 定时过期：CPU不友好，内存友好
- 惰性过期：访问的时候才判断key是否已经过期，CPU友好，内存不友好
- 定期过期：前两种折中，每个一段时间，扫描一定数量的key，删除其中已经过期的key。调整扫描的时间间隔和时间上线

#### Redis九大数据结构：

- string
  - 简单数据缓存，Redis分布式锁，就利用了这种数据结构，实现计数器，session共享，分布式ID
- list
  - 缓存微信公众号、微博等消息流数据
- hash
  - 存储key-value，适合用来存储对象
- set
  - 实现类似查找共同关注，朋友圈点赞功能
- 有序集合
  - 排行榜功能
- bitmap：布隆过滤器
- geohash：坐标，借助sorted set实现
- hyperloglog：统计不重复数据
- streams：内存版的kafka，消息的订阅发布

#### 分布式锁

分布式锁解决的问题本质是：对分布在多态机器中的线程对共享资源的互斥访问

- 基于MySQL，分布式环境中线程连接同一个数据库，利用数据库中的行锁来达到互斥访问，MySQL的加锁和释放锁的性能比较低，不适合真正的实际生成环境
- 基于zookeeper，zookeeper中的数据是存在内存的，相对于MySQL性能上是适合实际环境的，并且基于zookeeper的顺序节点、临时节点、watch机制能非常好的来实现分布式锁
- 基于Redis，Redis中的数据也是存在内存中的，基于Redis的消费订阅功能、数据超时时间、lua脚本等功能
