<h1 style="text-align:center;background:;">计算机网络</h1>

> [视频来源：b 站中科大计算机网络](https://www.bilibili.com/video/BV1JV411t7ow)

原理：每一层提供接口供上层使用
实例：网络层-传输层-应用层

可靠 reliable：不出错不重复不丢失不失序

对可靠性要求高：TCP 协议
对可靠性要求不高，对实时性要求高：UDP 协议

检错重传、超时重传、编号、校验、乱序排序占据接收方发送方空间，消耗时间，实时多媒体对时间要求非常高。
网络直播，实时多媒体，事物性应用

远程应用进程，报文交互，应用层协议，主机联网，远程的应用进程之间相互的通讯应该遵守的规则核协议。
浏览器和服务：规范好定义好两者之间交互的语法、语义和时序。

传输层为应用进程提供服务，传输层实在网络层提供的端到端的服务基础上进行实现的。端到端指的主机到主机，网络层提供的源主机到目标主机之间的 IP 数据包。主机到主机要经过好多路由器和交换机。提供的服务是主机到主机的，是尽力而为的，best ever，没有任何保障。IP 层能不能传到，会不会出错，乱不乱序，肯定乱序。
传输层是在网络层提供的服务基础上，主机到主机细分为进程到进程，把 IP 层提供的不可靠的服务通过 TCP 协议变成可靠的服务。
网络层：端到端，包括了若干个点到点，point to point，数字链路层相邻的两点之间的传输服务基础上实现，网卡所提供的数据链路层点到点。物理层：把数字的信号变成物理信号
传输层：end to end

网络层：

- 传统方式：
  - IP 协议，根据到来的路由表，IP 分组，到底往哪走，转发，路由：由路由协议交换路由信息，由路由算法算出路由表，由 IP 协议对到来的分组做转发的处理
  - 路由协议，路由实体与其他路由实体交换报文，路由选择算法，算出路由表，IP 的子网，该怎么走，给 IP 使用
    来了一个 IP 分组，有目标 IP 地址，跟路由算出来的路由表做匹配，判断 IP 落在哪个表项，表项中描述了这个 IP 应该从哪个端口放出去。
    因此 IP 的路由器包括了算出来的路由信息，哪些 IP 的子网该往哪边走。
    查路由表，查到了转发；查不到，按照默认的路径转走。路由器设置好就不会变的。
    缺点：升级，实现新的功能，基本不可能。设计问题，无法添加新功能。
- SDN：软件定义网络，弹性，更加灵活
  - 数据平面：交换机
    流表上载，根据流表描述的行为，动作这个分组
  - 控制平面：网络操作系统
    流表，flow table：目标 IP、源 IP……

###

### 概论:计算机网络和因特网

edge core access
Internet，互联网/网际：实际是由一堆网络构成，通过网络互联设备（路由器）连载一起的网络的网络。
互联网工作是 IP 分组交换工作：网络分组交换必然涉及丢包、分组传输延迟（四大延迟）、吞吐量（性能指标，定义）
一层一层解决，每一层实现一组特定功能，上一层借助下一层提供的服务，通过与对等层协议实体，相互交换协议报文来实现的，目的：为了向上一层提供更好的服务。应用层借助传输层提供的服务，交换应用报文实现各种应用功能。
分层体系架构：
链路层：传输相邻两个节点之间以帧为单位的数据。
网络层：在链路层实现的相邻两点之间传输服务的基础上源主机到目标主机之间的传输。端到端的数据传输。比较粗糙，丢包、出错、失序、错误。尽力而为 IP
传输层：在网络层提供的服务上加强了服务，细分服务，从主机到主机的服务细分成进程到进程，把它从不可靠变成了可靠。TCP/UDP
应用层：按照应用层协议交换应用报文，目的：实现各种各样的网络应用。

网络：节点和边的关系，和大小无关的关系的图
计算机网络：由联网的计算机构成的系统
节点包括主机节点（手机，电脑，冰箱，web 服务器）方的
数据交换节点（路由器交换机），转发数据，既不是源也不是目标 圆的
边也分为两类：主机通过边接入网络，叫接入电路
交换机之间的骨干电路

协议：支持互联网工作的标准
互联网：以 TCP/IP 协议为主一簇协议，由这些协议支撑起的网络就叫互联网

端系统：硬件、操作系统、网络应用
设备本身，操作系统，操作系统驻留的网络应用
host end 方的
switch 路由器 负载均衡设备 圆的

协议就是标准
对等层的实体在通信过程中应该遵守的标准
IETF
协议定了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接受或其他事件方面所采取的的动作。（语法和语义，时序和动作）
PDU（protocol data unit）
互联网是分布式应用进程，以及为分布式应用进程提供服务的基础设施
socketAPI（网络 API）

面向连接的可靠服务（TCP）和无连接的不可靠服务（UDP）

#### 网络边缘

网络结构：

- 网络边缘 edge
  - 主机
  - 应用程序（客户端和服务器）
- 网络核心 core 所有的边缘节点接在一起
  - 互连着的路由器
  - 网络的网络
  - 数据交换作用
- 接入网、物理媒体：access
  - 有线或者无线通信链路 把边缘接入到核心

网络边缘：

- 端系统
  - 运行应用程序
  - 个人 pc、手机等
- 客户端/服务器
  - 客户端向服务器发送请求
  - 服务器接收请求
  - 可扩展性较差，
  - 到达阈值断崖式下降
  - 可靠性差
- 对等模式 p2p（peer-peer）

  - 没有专门的服务器
  - 每个节点既是客户端也是服务器，通信是分布式的，多用在文件分发系统中
  - 下载文件片段 1 从服务器 1，片段 2 从服务器 2 等等

- 采用网络设施面向连接的服务：
  - TCP
  - 握手：数据传输之前做好准备
  - 可靠，不重复不失序不出错不乱序
  - 可靠地、按顺序传送数据
    - 确认和重传
    - 保序
  - 流量控制
    - 发送方不会淹没接收方
  - 拥塞控制
    - 当网络拥塞时，发送方降低发送速率
- 无连接的服务
  - UDP
    - 无连接
    - 不可靠数据传输
    - 无流量控制
    - 无拥塞控制
  - HTTP（Web）FTP（文件传送）
  - 流媒体、远程会议、DNS、Internet 电话
  - 事务性应用，查询过去结果回来
  - 网络实时多媒体应用

#### 网络核心

网络核心：路由器的网状网络

- 电路交换：预留专有电路
- 分组交换
  - 存储转发
  - 将要传送的数据分成一个个单位，分组
  - 一段一段经由路由器和交换机从源主机传送到目标主机

电路交换：通常用于电话网络
要求建立呼叫连接
专用资源、不共享
保证性能
通信建立时间
网络资源（如贷款）被分成片

- 频分交换节点之间的链路有效频率覆盖范围通过频分划分成若干小片两个主机在通信之间分一片 FDM
- 时分线路使用时间划分成很多个 T，每个 T 划分时间片，分一片 TDM
- 波分波段分成若干个小波段 WDM

电路交换不适合计算机之间通信
连接建立时间长
通信有突发性，浪费的片比较多
不是一直在使用

分组交换：
用就用所有，使用带宽的全部
全部接受存储进来再传给下一个节点 存储转发分为一个个包，完全存下来
按需使用
主机和主机之间的通信分组
换取共享性
耽误存储时间和排队时间
排队延迟
丢失：如果路由器缓存用完了，分组将会被抛弃

网络核心的关键功能：

- 路由：决定分组采用的源到目标的路径
  - 路径算法
- 转发：将分组从路由器的输入链路转移到输出链路

分组交换：

- 统计多路复用
  - 复用链路资源
- 划分时间片不固定
- 分组交换支持的用户数更多，在突发性请求的情况下

| 分组交换                                           | 电路交换                   |
| -------------------------------------------------- | -------------------------- |
| 适用于突发式数据传输，资源共享，简单不建立连接时间 | 资源不共享，要建立呼叫时间 |
| 过度使用会造成网络拥塞：分组延时和丢失`拥塞控制`   | 无分组延时和丢失           |

分组交换网络：存储-转发
分组交换：分组的存储转发一段一段从源主机到目标主机按照有无网络层的连接：分为

- 数据报网络
  - 分组的目标地址决定下一跳
  - 在不同阶段，路由可以改变
  - 类似问路
  - Internet
- 虚电路网络
  - 每个分组都带标签（虚电路表示 VC ID），标签决定下一跳
  - 在呼叫建立时决定路径，在整个呼叫中路径保持不变
  - 路由器维持每个呼叫的状态信息
  - X25 和 ATM

数据报工作原理
不建立连接：有数据就传输
每一个分组都独立路由：路径不一样，可能会失序
根据分组的目标地址进行路由

虚电路
根据虚电路表项存储转发

通信网络

- 电路交换网络
  - FDM
  - TDM
- 分组交换网络
  - 虚电路网络
  - 数据报网络

#### 接入网和物理媒体

住宅接入：modem
上网数据加载到音频信号上
调制和解调
调频、调幅、调相位、综合调制、带宽很窄

接入网（digital subscriber line，DSL）
采用现存的到交换局 DSLAM 的电话线
分上下行

接入网：线缆网络
非对称
有线电视信号线缆双向改造
各用户共享到线缆头端的接入网络

无线接入网络
无线 LAN
广域无线接入

物理媒体
5 类 100M bps
G pbs 千兆以太网
6 类 10G bps 万兆以太网
同轴电缆、光纤
光纤：低误码率两个中继器之间可以有很长的距离，不受电磁噪声干扰、告诉、每个光脉冲表示一个 bit、安全。光缆割开才能获取
传播环境效应：反射、吸收、干扰

#### Internet 结构和 ISP

端系统通过接入 ISP（Internet Service Providers）连接到互联网
互联网络结构：网络的网络

- 竞争
- 合作
  ICP 互联网内容提供商（谷歌、百度等）成本原因；向用户提供高质量服务，减少运营成本。建设全球各地机房，或者租，专线连接，离 ISP 比较近
  DC 数据中心连接若干 local ISP 个各级 ISP 更靠近用户

第一层 ISP（sprint）完成全球范围内覆盖，速率极高，直接与第一层 ISP 相连
与大量第二层 ISP 和其他客户网络相连
第二层 ISP 区域性 region
第三层 ISP 与其他本地 ISP

#### 分组延时、丢失和吞吐量

分组丢失和延时发生原因：

- 分组到达链路的速率超过了链路输出的能力
- 分组等待排到队头、被传输，排队被排满了，后来数据会被丢失

四种分组延时

- 节点处理延时
  - 检查分组情况，检查链路
- 排队延时
  - 在输出链路上等待传输的时间
  - 依赖于路由器的拥塞程度
- 传输延时
  - R=链路带宽（bps）
  - L=分组长度（bits）
  - 将分组发送到链路上的时间=L/R
- 传播延时
  - 每一个 bit 都要传输距离所花时间
  - d=链路长度
  - s=链路上传播速度
  - 传播延时=d/s

信道容量：当传出去第一个 bit 还没到达下一个路由器就已经传完了分组

节点延时
`d_nodal=d_proc+d_queue+d_trans+d_prop`

- d_proc=处理延时 通常微妙数量级
- d_queue=排队延时 却绝于拥塞程度
- d_trans=传输延时 通常为微妙到毫秒
- d_prop=传播延时 几微妙到几百毫秒

R=链路带宽（bps）
L=分组长度（bits）
a 分组达到队列的凭据速率
流量强度=La/R 排队延时与流量强度非线性增长，tan 函数
La/R -> 1 时排队延时会非常大，凭据排队延时将趋向于无穷大

windows **tracert** 提供从源端经过路由器到目标的延时测量
沿着目的路径向每个路由器发送 3 个探测分组 路由器 i 向发送方返回一个分组，发送方对发送和回复之间间隔计时
利用了 ICMP 协议，互联万控制包协议
head IP 头 body IP 数据
分组字段，ip 有一个头部，TTL 字段（head 中）生存时间 TTL 减为 0 就抛掉同时路由器根据 ICMP 协议发送报文给发送端消息告诉发送方分组抛掉
到达目标主机时返送目标端口不可达消息给源主机
从源到目标主机的延迟

分组丢失：

- 链路的队列缓冲容量有限
- 分组到达一个满的队列将会被丢失
- 丢失的分组可能会被前一个节点或源端系统重传，或根本不重传

重传情况

- 源主机重传
  - TCP
- 前一节点重传
  - 如果链路不可靠不重传
- 放弃重传
  - UDP

吞吐量: 在源端和目标端之间传输的速率（数据量/单位时间）

- 瞬间吞吐量: 在一个时间点的速率
- 平均吞吐量: 在一个长时间内平均值
  瓶颈链路：端到端路径上，限制端到端吞吐的链路
  短板效应吞吐量等于各个链路中最小的

#### 协议层次及服务模型

模块化和分层
计算机分层方式：只有相邻两层才能调用

层次化方式实现复杂网络功能:

- 将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务
- 本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务
- 在实现本层协议的时候，直接利用了下层所提供的服务
- 本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务

服务( Service)：低层实体向上层实体提供它们之间的通信的能力
原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的---形式
服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—地点；SAP 区分服务用户
PDU（protocol data unit）协议数据单元

通信之前要不要握手，要的话就是面向连接的服务否则就是无连接的服务

服务和协议关系

- 服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直
- 协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平
- 本层协议的实现要靠下层提供的服务来实现
- 本层实体通过协议为上层提供更高级的服务

SAP（service access point）
IDU（interface data unit）
PDU（protocol data unit）协议数据单元
SDU（service data unit）服务数据单元
应用层 PDU：应用报文
传输层 PDU：报文段或者段
网络层 PDU：分组或（IP 数据报）
物理层 PDU：帧
ICI（interface control information）控制信息
SDU 需要加上 ICI 穿过层间接口
拿到 SDU 之后需要加上本次的控制信息，两个加在一起形成了 PDU
SDU 非常大时，分为多个 SDU，每个加上头部形成一个大小合适的 PDU
SDU 非常小时，将若干个 SDU 合在一起形成，加上本层头部形成 PDU
本层头部一部分是 ICI 转变过来的，一部分是本层附加上去的

- 概念化：结构清晰，便于标示网络组件，以及描述其相互关系
  - 分层参考模型
- 结构化：模块化更易于维护和系统升级
  - 改变某一层服务的实现不影响系统中的其他层次
    - 对于其他层次而言是透明的
  - 如改变登机程序并不影响系统的其它部分
    - 改变 2 个秘书使用的通信方式不影响 2 个翻译的工作
    - 改变 2 个翻译使用的语言也不影响上下 2 个层次的工作

Internet 协议栈：

- 应用层：网络应用
  - FTP，SMTP，HTTP，DNS
- 传输层：进程到进程的区分，把 IP 层提供的不可靠的服务变为可靠
  - TCP、UDP
- 网络层：在链路层的服务上，端到端的传输，不可靠
  - IP，路由协议
- 链路层：相邻两点传输以帧为单位的数据
  - 点对点传输协议，以太网、WLAN
- 物理层：在线路上传输 bit，把上层传下来的 frame 帧转换成物理信号，传输，把物理信号转成 frame

ISO/OSI 参考模型
表示层: 允许应用解释传输的数据, e.g., 加密，压缩，机器相关的表示转换
会话层: 数据交换的同步，检查点，恢复

应用层：报文（message）
传输层：报文段（segment）
网络层：分组（packet），无连接数据报（datagram）
链路层：帧（frame）
物理层：位（bit）

发送时一层一层封装，然后收到后一层一层解封

链路交换机：两层解封，装再封装
路由器：三层解封装，再封装

#### 小结

- 组成角度看 什么是互联网
  - 边缘：端系统（包括应用）+接入网
  - 核心：网络交换设备+通信链路
  - 协议：对等层实体通信过程中遵守的规则的集合
    - 语法，语义，时序
- 为了实现复杂的网络功能，采用分层方式设计、实现和调试
- 应用层，传输层，网络层，数据链路层，物理层
- 协议数据单位：
  - 报文，报文段，分组，帧，位
- 从服务角度看互联网
- 通信服务基础设施
  - 提供的通信服务：面向连接 无连接
- 应用
- 应用之间的交互
- C/S 模式
- P2P 模式
- 数据交换
  - 分组数据交换
  - 线路交换
- 比较 线路交换和分组交换
- 分组交换的 2 种方式
  - 虚电路
  - 数据报
- 接入网和物理媒介
  - 接入网技术：
    - 住宅：ADSL，拨号，cable modem
    - 单位：以太网
    - 无线接入方式
  - 物理媒介
    - 光纤，同
- 分组交换网络中延迟和丢失是如何发生的
  - 延迟的组成：处理、传输、传播、排队
- 网络的分层体系结构
  - 分层体系结构
  - 服务
  - 协议数据单元
  - 封装与解封装

### 应用层

#### 2.1 应用层协议原理

网络应用的体系结构

- C/S 模式：C/S：client/server
- 对等模式 peer to peer P2P
  - 任意端系统之间可以通信
  - 每一个接地那既是客户端也是服务器
- 混合体：

进程间通信：

- 同一个主机内，借助操作系统管道、消息队列、共享缓冲区
- 通过交换报文进行通信
  - 借助操作系统提供的通信服务
  - 按照应用协议交换报文

进程间通信问题：

- 进程标识和寻址寻址问题
- 传输层-应用层如何提供服务
  - 位置：SAP（TCP/IP：socket）
  - 形式：API（TCP/IP：socket API）
- 如何使用传输层提供的服务进行应用进程间的报文交换

标识应用进程（end point）
IP
TCP/UDP
端口（TCP 和 UDP 各有 2\*\*16=65536 个端口）

穿过应用层-传输层接口需要：
发的信息 SDU
发给谁：对方的 IP 和端口号
谁传信息:主机 IP，应用进程所使用的端口号

socket API
TCP socket 套接字（）
4 元祖（源 IP，源 port，目标 IP，目标 port）
唯一的指定了一个会话（2 个进程之间的会话关系）
应用使用这个标示，与远程的应用进程通信
不必在每一个报文的发送都要指定这 4 元组
就像使用操作系统打开一个文件，OS 返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名
socket 本地标识
便于管理和穿过层间信息最少
应用层和传输层的约定
TCP socket 用于指定应用进程的本地标示
socket 套接字代表会话关系是一个四元组

UDP socket：只代表本地 IP 本地端口
两个进程之间通信无需建立连接
每个报文都是独立传输，前后报文可能是给不同的分布式进程
UDP socket：本机 IP，本机 port
传输报文时必须提供对方的 IP，port
接收报文时，传输层需要向应用层提供对方的 IP，port
在发送数据报时，采用创建好的本地套接字（标示 ID），就不必在发送每个报文中指明自己所采用的 ip 和 port

应用层协议
定义了：运行在不同端系统上的应用进程如何相互交换报文
应用协议仅仅是应用的一个组成部分

Web 应用：HTTP 协议，web 客户端，web 服务器，HTML

如何描述传输层的服务：

- 数据丢失率
- 吞吐
- 延迟
- 安全性

|     应用     | 数据丢失率 |           吞吐           | 时间敏感性 |
| :----------: | :--------: | :----------------------: | :--------: |
|   文件传输   |  不能丢失  |           弹性           |     不     |
|    email     |  不能丢失  |           弹性           |     不     |
|   web 文档   |  不能丢失  |           弹性           |     不     |
|   实时音频   |  容忍丢失  | 音频：0.5M-1M 视频：0-5M | 是，100ms  |
| 存储音频视频 |  容忍丢失  |           同上           |  是，几秒  |
|  交互式游戏  |  容忍丢失  |         几 K~10K         | 是，100ms  |
|   即时通讯   |  不能丢失  |           弹性           |  是和不是  |

TCP 实体：实现网络协议的软件模块和硬件模块，而且是运行中的软件模块和硬件模块

| TCP 服务                                           | UDP 服务                                                         |
| -------------------------------------------------- | ---------------------------------------------------------------- |
| 可靠地传输服务                                     | 不可靠的数据传输                                                 |
| 流量控制                                           | 不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接 |
| 拥塞控制                                           |                                                                  |
| 不能提供的服务：时间保证、最小吞吐保证和安全       |                                                                  |
| 面向连接：要求在客户端进程和服务器进程之间建立连接 |                                                                  |

UDP 存在的必要性：

- 能够区分不同的进程，IP 服务不能
- 无需建立连接，省去了建立连接的时间，适合事务性的应用
- 不做可靠性的工作，省去了为了可靠性要求的时间代价
- 没有拥塞控制和流量控制，应用能够按照设定的速度发送数据

|     应用      |        应用层层协议         | 下层传输协议 |
| :-----------: | :-------------------------: | :----------: |
|     email     |            SMTP             |     TCP      |
| 远程终端访问  |           Telnet            |     TCP      |
|      Web      |            HTTP             |     TCP      |
|   文件传输    |             FTP             |     TCP      |
|    流媒体     | 专用协议（如 RealNetworks） |  TCP 或 UDP  |
| Internet 电话 |  专用协议（如 Net@Phone）   |  TCP 或 UDP  |

安全性：

- TCP 和 UDP
  - 都没有加密
  - 明文传输
- SSL
  - TCP 基础上实现，应用层服务
  - 私密性
  - 数据完整性
  - 端到端的鉴别
  - 采用 SSL 库，SSL 库使用 TCP 通信

#### 2.2 Web 和 HTTP WWW 万维网(world wide web) HTTP( HyperText Transfer Protocol)

URL 格式：
协议名://用户:口令@主机名/路径名:端口

Web 的应用层协议是超文本传输协议
HTTP：

- 客户端发起一个与服务器的 TCP 连接（建立套接字），端口号 80
  服务器接收客户的 TCP 连接
  在浏览器 HTTP 客户端与 Web 服务器（HTTP server）交换 HTTP 报文
  TCP 连接关闭
  HTTP 是无状态的，服务器不维护关于客户的任何信息
  无状态服务器好处：
- 简单
- 来了连接就服务
- 可以支持更多的客户

HTTP 连接
|非持久 HTTP|持久 HTTP|
|---|---|
|最多只有一个对象在 TCP 连接上发送|多个对象可以在一个 TCP 连接上传输|
|下载多个对象需要多个 TCP 连接|HTTP/1.1 默认使用持久连接|
|HTTP/1.0 使用非持久连接||

非持久连接
连接请求过去，连接请求确认回来
http 请求，http 响应
连接拆除，连接拆除确认

持久连接
连接建立请求，连接建立确认回来
http 请求，http 对象回来
连接不关
如果还有其他请求，仍然在这个连接上发送请求
流水方式和非流水方式
流水方式是 HTTP/1.1 默认方式

往返时间(Round-Trip Time,RTT)：一个短分组从客户到服务器然后再返回客户所话费时间

HTTP 请求报文 ASCII
第一行请求行
请求行

- 方法字段
- URL 字段
- HTTP 版本字段
  首部行
  换行回车符表示报文结束

请求报文

```HTML
GET /somedir/page.html HTTP/1.1 <!--方法行-->
<!-- 首部行-->Host:www.someshcool.edu <!--指明了对象所在的主机-->
<!-- 首部行-->Connection:close<!--告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接-->
<!-- 首部行-->User-agent:Mozilla/5.0<!--知名用户代理，即向服务器发送请求的浏览器的类型-->
<!-- 首部行-->Accept-language:fr<!--表示用户想得到该对象的法语版本，否则服务器应当发送它的默认版本-->
```

请求方式：方法字段
GET:
POST:
HEAD:维护或者索引
PUT:向服务器提交对象
DELETE:用户删除服务器上的对象

HTTP 响应报文

```HTML
HTTP/1.1 200 OK<!--初始状态行-->

Connection:close<!--六个首部行-->
Date:Tue, 09 Aug 2011 15:44:04 GMT
Server:Apache/2.2.3(CentOS)
Last-Modified:Tue, 09 Aug 2011 15:11:03 GMT
Content-Length:6821<!--内容长度/多少字节是内容长度,TCP向上层提供时不分割，传15K*2，TCP提供是30K，需要应用层去区分-->
Content-Type:text/html

(data data data data data data ...)<!--实体体-->
```

一个初始状态行
六个首部行，然后是实体体
实体体是报文的主要部分，即它包含了所请求的对象本身
状态行有三个字段，协议版本字段，状态码和响应状态信息

常见的状态码：

- 200 OK：请求成功
- 301 Moved Permanently：请求的对象已经被永久转移了，新定义的 URL 在响应报文的 Location：首部行中。客户软件将自动获取新的 URL
- 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解
- 404 Not Found：被请求的文档不在服务器上
- 505 HTTP Version Not Support：服务器不支持请求报文使用的 HTTP 协议版本

用户与服务器的交互：cookie

HTTP是无状态协议，服务器不维护客户端状态，同样的服务器资源可以提供服务给更多的客户端

第一次发送请求没有Cookie，服务器接收到浏览器第一次发送的请求，会给客户端分配一个Cookie同时在服务器本地数据库保留这个Cookie，同时在Response报文头部塞一个Set-cookie，客户端拿到Cookie之后会存到本地文件系统中下次访问时，就会把Cookie带上
Cookie：包括四个部分
- 在Response报文中有一个Cookie的首部行
- 在请求报文中有一个Cookie的首部行
- 在用户端系统中保留一个Cookie文件，由用户的浏览器管理
- 在Web站点有一个后端数据库存储Cookie



Web缓存

Web cache也叫代理服务器

优点：
- 快
- 服务器负载更轻
- 网络负担也减轻





















#### 2.3 FTP                                                                                                                                                                                                                                                                                                                                                                

#### 2.4 SMTP

#### 2.5 DNS



#### 2.6 P2P 应用



#### 2.7 CDN

cdn：内容加速服务

杀手级业务：视频业务

问题：并发问题，规模性；每个节点上下带宽不同，需求不一样，异构问题
解决方案：分布式的、应用层面的基础设施
编码：

- 时间冗余
- 空间冗余



#### 2.8 TCP 套接字（socket）编程

IP地址和port捆绑关系的数据结构
```c++
struct sockaddr_in{
    short sin_family;//AF_INET,地址簇
    u_short sin_port;//port,端口
    struct in_addr sin_addr;//IP address,unsigned long,IP地址
    char sin_zero[8];//align,对齐
}
```

域名和IP地址的数据结构
```c++
struct hostent{
    char *h_name;//主机域名
    char **h_aliases;//主机的一系列别名
    int h_addrtype;//
    int h_length;//地址长度
    char **h_addr_list;//IP地址列表
    #define h_addr h_addr_list[0];//IP[0]代表解析出来后的地址
}
```
#### 2.9 UDP 套接字编程




#### 总结

|||
|---|---|
|HTTP|80|
|FTP|21|
|SMTP|25|
|POP3|110|
|DNS|53|



### 运输层

#### 3.1 概述和传输层服务



#### 3.2 多路复用与分解复用

多路分解就是把在运输层把把运输层报文段中的数据交付给对应的套接字
多路复用就是把不同套接字传来的数据块加上首部信息后生成报文段，然后将报文段传给网络层

#### 3.3 无连接传输: UDP

使用UDP原因：

- 只要传给UDP数据，UDP就会将数据打包进UDP报文段传给网络成发送出去
- 无需建立连接
- 无连连接状态
- 分组首部开销小，TCP报文段20字节首部开销，UDP报文段仅有8字节

UDP报文段结构

UDP提供了数据交付和差错检查功能
差错检查功能是通过检验和实现的，但是对差错恢复无能为力。UDP的实现一是丢弃受损的报文；一是将受损的报文段交给应用程序并给出警告。

#### 3.4 可靠数据传输的原理

GBN协议和SR协议的异同：

- 相同之处
  - 发送窗口大>1
  - 一次能够发送多个未经确认的分组
- 不同之处
  - GBN：接收窗口=1
    - 接收端：只能顺序接收
    - 发送端：从表现上来看一旦一个分组没有发送成功，要返回base重新发送所有已发送但未确认的分组
  - SR：接收窗口>1
    - 接收端：可以乱序接收
    - 一旦有有一分组未成功（丢失或错误）重新发送该分组即可
    - 传递给上层时是顺序传递，发送1，2，3，4，5时，3，4正确，接收端也返回了3，4的ACK，但1，2没有到达或者错误，发送端超时重传，如果正确分组到达的次序是2，1，那么接收端先返回2的ACK，接收1返回1的ACK，此时再按照顺序1，2，3，4，5依个向上层传递分组，进行解封装传递数据工作。

|                        go-back-N，GBN                        | selective Repeat，Sr                         |
| :----------------------------------------------------------: | -------------------------------------------- |
|          发送端最多有在流水线中有N个未经确认的分组           | 发送端最多在流水线中有N个未经确认的分组      |
| 接收端只是发送累计型确认，接收端如果接收到当前等待分组之后的分组，抛弃，不确认 | 接收方对每个到来的分组单独确认               |
|              发送端拥有最老的未确认分组的定时器              | 发送方为每个未确认的分组保持一个定时器       |
|    只需设置一个定时器，当定时器到时时重传所有未确认的分组    | 当定时器到时时，只是重新发送到时的未确认分组 |

|      | GBN                                    | SR                                         |
| ---- | -------------------------------------- | ------------------------------------------ |
| 优点 | 简单，所需资源少（接收方一个缓存单元） | 出错时，重传一个代价小                     |
| 缺点 | 一旦出错，回退N步代价大                | 复杂，所需要资源多，（接收方多个缓存单元） |

适用范围：

- 出错率低：比价适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂的处理
- 链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一旦出错代价太大



#### 3.5 面向连接的传输:TCP

- 点对点：一个发送方，一个接收方
- 可靠地、按顺序的字节流：没有报文边界
- 管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小
- 发送和接收缓存
- 全双工数据：
  - 在同一连接中数据流双向流动
  - MSS（Maximum Segment Size）最大报文段大小：1460B
- 面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量
- 有流量控制：发送方不会淹没接收方

以太网Maximum Transmission Unit，MTU：1500B
20B TCP头部，20B IP头部，加上最大报文段1460B一共1500B，正好封装在以太网的载荷部，就不存在分片的问题

TCP报文段结构：

![TCP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP报文.png)



![TCP 首部](https://gitee.com/huihut/interview/raw/master/images/TCP首部.png)

序号（32bit）：载荷部分第一个字节在整个报文中的偏移量
确认号（32bit）：期望从临沂房收到的下一个字节的序号

TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：

* URG：紧急比特（urgent），当 `URG＝1` 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。
* ACK：确认比特（Acknowledge）。只有当 `ACK＝1` 时确认号字段才有效，代表这个封包为确认封包。当 `ACK＝0` 时，确认号无效。
* PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
* RST：复位比特(Reset)，当 `RST＝1` 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
* SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
* FIN：终止比特(Final)，用来释放一个连接。当 `FIN＝1` 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

往返时间估计

| 估计 |      |
| ---- | ---- |
| SampleRTT均值EstimatedRTT=(1-α) ×EstimatedRTT+α×SampleRTT | α参考值为0.125 |
| RTT偏差DevRTT=(1-β)×DevRTT+β×\|SampleRTT-EstimatedRTT\| | β推荐值为0.25 |
| 重传超时时间间隔TimeoutInterval=EstimatedRTT+4×DevRTT | 推荐TimeoutInterval初始值为1秒，出现超时后加倍，以免即将被确认的后继报文段过早出现超时。不管怎样，一旦报文段收到并更新EstimatedRTT后，TimeoutInterval将使用公式计算了。 |

流量控制：

- 接收窗口的变量来提供流量控制，指示接收方还有 多少可用的缓存空间
- 主机A通过TCP连接向主机B发送一个大文件
- 主机B为该连接分配了一个接收缓存，并用RcvBuffer来表示其大小
- RcvBuffer大小可以通过socket选项设置
- LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号
- LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节编号
- 由于TCP不允许已分配的缓存溢出所以：`LastByteRcvd-LastByteRead≤RcvBuffer`
- 接收窗口用rwnd表示，根据缓存可用空间的数量来设置：`rwnd=RcvBuffer - [ LastByteRcvd - LastByteRead ]`
- 主机A必须轮流跟踪连个变量，`LastByteSent`和`LastByteAcked`，必须保证：`LastByteSent - LastByteAcked ≤ rwnd`
- 当`rwnd=0`时，由于TCP仅当在它有数据或有确认要发送时才会发送报文段给主机A。这样主机A不可能直到主机B的接收缓存已经有新的空间了，即主机A被阻塞而不能发送数据了
- TCP规范要求：当`rwnd=0`时主机A持续发送只有一个字节数据的报文段，这些报文段将会被接收方确认，最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值

连接管理：

- 第一次：客户端随机选择一个seq=client_isn，与报文段中SYN=1封装在一起发送给服务器端
- 第二次：服务器接收到客户端请求，如果同意建立连接，就随机选择一个seq=server_isn，与报文段中SYN=1，ACK=clinet_isn+1，封装在一起发送给客户端。
- 第三次：客户端接收到服务端返回消息，SYN=0，seq=client_isn+1，ACK=server_isn+1，发送给服务器端。
- 三次握手完毕连接建立，第三次握手可以附带数据。

为什么不两次握手：

- 变化的延迟（连接请求的段没有丢失但可能超时）
- 由于丢失造成的重传（e.g.req_conn(x)）
- 如果两次握手，假如客户端发送的请求延迟到客户端的连接关闭了，此时连接请求到达了服务器端，因为两次握手，所以会建立一个虚假的连接，其后还在网络中的数据请求到达了服务器端，因为已经建立了连接，所以服务器端还是会照常发送数据
- 报文乱序
- 相互看不到对方

两次握手的失败场景：

- 半连接，只在服务器端维护了连接，服务器维持了连接，客户端没有维护
- 老数据被当成新数据接受了

为什么不四次握手？

- 因为服务选择自己的server_ins的时候可以捎带在第二次握手的确认连接中即对第一次SYN=1，seq=client_ins的确认连接的回复SYN=1，ACK=client_ins+1中捎带上seq=server_ins

##### TCP 为什么要进行三次握手？

【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）

> [Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}](https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ)

【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

> [知乎 . TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633/answer/115173386)

【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

> [《计算机网络（第 7 版）-谢希仁》](https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png)

【TCP 释放连接全过程解释】

1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
4. 服务端继续发送之前没发完的数据给客户端；
5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；
7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

TCP连接关闭并不完美
对称释放



##### TCP什么要进行四次挥手

【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？

【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

【答案三】

1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

TCP有限状态自动机

![TCP 的有限状态机](https://gitee.com/huihut/interview/raw/master/images/TCP的有限状态机.png)

#### 3.6 拥塞控制原理

拥塞的原因：

- 分组到达速率超过链路处理速率
- 

拥塞的代价：

- 当分组的到达速率接近链路容量时，分组经历巨大的排队时延
- 发送方必须执行重传以补偿因为缓存溢出而丢弃的分组
- 发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本
- 一个分组沿一条路径被丢弃时，每个上游路由器由于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了

拥塞控制方法：

##### 端到端的拥塞控制

- 没有来自网络的显示反馈
- 端系统根据延迟和丢失时间腿短是否有拥塞
- TCP采取的方法

##### 网络辅助的拥塞控制

- 路由器提供给端系统以返回信息
  - 单个bit置位，显示有拥塞（SNA，DECbit，TCP/IP ECN，ATM）
  - 显式提供发送端可以采用的速率



#### 3.7 TCP拥塞控制

端到端的拥塞控制

TCP拥塞控制机制追踪一个额外的变量，即拥塞窗口（congestion window）`cwnd`，在一个发送方中未被确认的数据量不会唱过`cwnd`与`rwnd`中的最小值，即`LastByteSent-LastByteAcked≤min(cwnd,rwnd)`

TCP发送方如何感知拥塞：
丢包事件：幺妹出现超时，要么收到来自接收方的3个冗余ACK

TCP发送方如何控制发送速率

- 粗略控制
  - 
    
    $$
    rate\approx\frac{CongWin}{RTT}bytes/sec
    $$
    
  - CongWin是动态的，是感知到的网络拥塞成都的函数
    - 超时或者重复超过3个ACK，CongWin下降
      - 超时时，CongWin降为1MSS，进入SS阶然后再倍增到CongWin/2（每个RTT），从而进入CA阶段
      - 3个重复ACK：CongWin降为CongWin/2，CA阶段（拥塞避免阶段）
    - 否则（正常收到ACK，没有出现以上情况）：
      - SS阶段：加倍增加（每个RTT）
      - CA阶段：线性增加（每个RTT）

TCP拥塞控制和流量控制的联合动作：
`SendWin=min(CongWin,RecvWin)`









​    

​    





TCP拥塞控制算法：

- 慢启动
  - 线性增，乘性减少
  - 超时时间后的保守策略
  - 连接刚建立CongWin=1MSS
  - 每当传输的报文段首次被确认就增加1个MSS
  - 每个RTT CongWin翻倍
  - 只要不超时或3个重复的ACK，一个RTT，CongWin加倍
  - 初始速率很慢，但是加速却是指数性的
  - 如何结束这种增长
    - 超时指示的丢包事件（即拥塞）把ssthresh设置为cwnd/2，cwnd设置为1重新开始慢启动过程
    - 当cwnd=ssthresh时，结束慢启动，并且TCP转移到拥塞避免模式，进入拥塞避免模式TCP会更谨慎地增加cwnd
    - 如果检测到3个冗余ACK，这时TCP执行一种快速重传，ssthresh的值变为cwnd的值的一半，cwnd=ssthresh+3MSS，并进入快速恢复状态
- 拥塞避免
  - 一旦进入拥塞避免状态cwnd的值大约为上次遇到拥塞时的值得一半
  - 保守增加每个RTT只将cwnd的值增加一个MSS
  - 出现超时时，cwnd的值被设置为1个MSS，ssthresh的值被更新为cwnd的值得一半
  - 如果收到三个冗余的ACK，ssthresh的值记录为cwnd的值的一半，cwnd变为ssthresh加上三个MSS，进入快速恢复状态
- 快速恢复
  - 对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS，最终当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态
  - 如果出现超时，则ssthresh设置为cwnd的值的一半，cwnd=1MSS进入慢启动阶段
  - 快速恢复是TCP推荐的而非必须的构建。
  - TCP Reno

TCP拥塞控制总结：

- 加性增、乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）

TCP平均吞吐量：
$$
\mit一条连接的的平均吞吐量=\frac{0.75\times{W}}{RTT}，W表示拥塞窗口长度
$$

### 网络层：数据平面

网络层两个功能：转发（数据平面）和路由选择（控制平面），每个功能又有传统方式和SDN方式，组合一共四种，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

路由是规划源主机到目标主机的详细路径，转发是对每一个数据交换节点，从某个端口入，从某个端口出，路由决定了路径，转发决定了从一个具体的数据节点哪个端口入，哪个端口出

转发：需要路由表，依赖路由表，依靠路由功能算出来，数据平面，对到来的数据报怎么处理，
路由功能是控制平面功能

数据平面：

- 本地，每个路由器功能
- 决定从路由器输入端口到达的分组如何转发到输出端口
- 转发功能：
  - 传统方式：基于目标地址+转发表
  - SDN方式：基于多个字段+流表

控制平面：

- 网络范围内的逻辑
- 决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端的路径
- 方法
  - 传统路由选择算法：在路由器中被实现
    - 紧耦合、很难修改
    - 数据平面和控制平面在一起，分布式计算
  - SDN：在远程服务器中实现
    - 转发、泛洪、（阻止）block、修改某些字段
    - 灵活性大很多
    - 多个字段的流表匹配，南向接口，mac、地址、ip、

传统方式：每一个路由器中的单独路由器算法元件，在控制平面进行交互，控制片面：路由思安发决定了端到端的路径，数据平面：IP协议根据转发表决定了IP数据报在此路由器上的局部转发，根据IP地址和端口号进行转发

SDN方式（软件定义网络）：逻辑集中的控制平面，一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互

除了转发和路由选择功能之外，网络层提供了连接建立功能，在分组传输之前，在两个主机之间，在通过一些路由器所巩固成的罗京上建立一个网络层连接，从源目的地沿着所选择的路径彼此握手，以便在给定源到目的地连接中的网络层数据分组能够开始流动之前建立起状态。在网络层，该工程被称为连接建立。

网络服务模型：

- 对于单个数据报的服务：
  - 可靠传送（确保交付）：该服务确保分组将最终到达其目的地
  - 延迟保证（具有时延上街的确保交付）：该服务不仅确保分组的交付，而且特定的主机到主机的时延上界内交付
- 对于分组流（数据报流）的服务：
  - 有序分组交付：确保分组以它们发送的顺序到达目的地
  - 确保最小带宽：
  - 确保最大时延抖动：
  - 安全性服务：
- 网络层提供了单一的服务，是一种尽力而为的服务
  - 分组见得定时是不能确保被保证的，分组接受的顺序也不能保证与发送的顺序一致，传送的分组也不能保证最终被交付

虚电路和数据报网络：

- 在网络层提供技连接服务的计算机网称为虚电路网络
  - ATM、帧中继体系是虚电路网络
  - 虚电路的组成：
    - 源和目的主机之间的路径（即一系列链路和路由器）
    - VC号，沿着该路径的每段链路的一个号码
    - 沿着该路径的每台路由器中的转发表表项
  - 在虚电路网络中，路由器必须为进行中的连接维持连接状态。没当跨越一台路由器创建一个新连接，必须在该路由器的转发表中增加一个新的连接项；每当释放一个连接，必须从该表中删除该项
  - 虚电路的三个状态：
    - 虚电路建立：建立阶段，发送运输层与网络层联系，指定接收方地址，等待网络建立虚电路
    - 数据传送：一旦创建了虚电路，分组就可以开始沿着该虚电路流动
    - 虚电路拆除：当发送方（接收方）通知网络层希望终止虚电路时，网络层通知网络另一侧的端系统结束呼叫，并更新路径上每天分组路由器中的转发表以表明该虚电路已不存在了
- 仅在网络层提供无连接服务的计算机网络城管称为数据报网络
  - 因特网是一个数据报网络
  - 每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将该分组推进网络中，无需建立任何虚电路，没有虚电路，因此也不维护西电路状态信息。
  - 每台路由器都使用分组的目的地址来转发该分组，每台路由器都一个目的地址映射到链路接口的转发表；当分组到达路由器时，路由器用该分组的目的地址在转发表中查找适当的输出链路接口，然后路由器将该分组向该输出链路接口转发
  - 转发规则：前缀匹配：多个匹配，最长前缀匹配
- 运输层面向连接的服务是在位于网络边缘的端系统中实现的，网络层连接服务除了在端系统中，也在位于网络核心的路由器中实现
- 虚电路网络和数据报网络是计算机网络的两种基本类型

路由器工作原理：

- 路由：由路由选择算法/协议（RIP、OSPF、BGP）生成路由表
- 转发：从输入到输出链路交换数据报-根据路由表进行分组的转发
  - 最长前缀匹配
- 路由器组成：
  - 输入端口：
    - 功能：
      - 输入的物理链路与路由器相连接的物理层功能
      - 需要与位于入链路远端的数据链路层交互的数据链路层功能
      - 查找功能，在输入端通过查找转发表决定路由器的输出端口，到达的分组通过交换接狗狗转发到输出端口
    - 输入端口，存储了路由选择处理器计算和更新的路由表的影子副本，直接输入端口本地就能做出转发决策，避免了集中式处理的瓶颈
  - 交换结构：
    - 经内存交换
      - 处理器从输入端口读取分组到内存，提取目的地址在转发表中找出适当地输出端口，然后再从内存中复制到输出端口缓存
      - 许多现代路由器就是通过内存进行交换，不同的是目的地址的朝招和将分组存储进适当地内存存储位置时由输入线路卡完成的
    - 经总线交换
      - 输入端口经一根共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预
      - 输入端口为分组预先计划一个交换机内部标签，该分组能被所有输出端口收到，但只有与该标签匹配的端接口才能保存该分组，然后标签在输出端口被去除
      - 如果同时多个分组到达路由器，那么必须等待，因为一次只有一个分组能跨越总线。所以路由器的交换带宽受总线速率的限制
    - 经互联网络交换
      - 通过控制纵横式交换机2N条总线，连接N个输入端口与N个输出端口，通过交换结构控制器，选择闭合输入端口和输出端口与总线连接的闭合来控制分组转发
      - 能够并行转发多个分组，如果两个不同输入端口的两个分组目的地为相同的输出端口，则一个分组必须在输入端等待，因为某个时刻经给定总线仅有一个分组能够发送
  - 输出端口：
    - 输出端口处理取出粗放在输出端口内存中的分组，并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层传输功能
  - 路由选择处理器：
    - 执行路由选择协议，维护路由选择表，以及连接的链路状态信息，并未路由器计算转发表。
    - 网络管理功能
- 排队：
  - 输入端口和输出端口处都能够形成分组队列
  - 随着队列增长，路由器缓存空间将会被耗尽，并且当内存可用于存储到达的分组时将会出现丢包
  - 分组调度程序
    - 先来先服务（FCFS）调度
    - 加权公平排队（WFQ）
    - 分组调度程序在提供服务质量保证方面起着关键作用
  - 如果没有足够内存空间来缓存一个分组
    - 弃尾
    - 删除一个或多个已排队的分组



网际协议：因特网中的转发和编址

因特网的网络层三个组件：

- IP（网际协议）协议：编址规则；数据报格式；分组处理规则
- 路由选择协议：路由选择；RIP、BGP、OSPF，算出转发表
- ICMP（因特网控制报文协议）协议：差错报告；路由器“信令”，主要目的就是报告错误，报告数据报中的差错和对某些网络层信息进行请求响应的设施，ping的请求就是一个ICMP分组，返回一个ICMPresponse

IP数据报格式：![IP数据报格式](../assets/IP数据报格式.png)

- 版本号：4bit，规定了数据报的IP协议版本，通过版本号，路由器能够确定如何解释IP数据报的剩余部分
- 首部长度：







### 网络层：控制平面  

单播：点对点的通信路由选择协议
广播：源节点到网络中所有其他节点交付分组的服务
多播：单个源节点能够向其他网络节点的一个子集发送分组的副本

广播路由选择算法：无控制洪泛导致广播风暴，大量无用的广播分组充斥在网络中

- 发送节点向每个目的地发送分组的副本
- DHCP洗衣
- 序号控制洪泛
- 反向路径转发
- 生成树广播

多播路由选择算法：

- 多播分组仅被交付给网络节点的一个子集
- 常用语批量数据传送、流式连续媒体、数据共享应用、数据供给、Web缓存更新、交互式游戏等
- 距离向量多播路由选择协议

### 链路层：链路、接入网和局域网

##### 链路层提供的服务：

- 成帧：每个网络层数据报警链路传送之前，都要用链路层帧将其封装。
- 链路接入：媒体访问控制（MAC）协议：规定了帧在链路层上的传输规则。点对点传送中，MAC协议比较简单。当多个节点共享单个广播链路时，所谓多路访问问题，MAC用于协调多个节点的帧传输。
- 可靠交付：链路层的可靠交付服务是通过确认和重传取得的。链路层可靠交付服务通常用于易产生高差错率的链路，例如无线链路
- 差错检测和纠正：比特差错是由信号衰减和电磁噪声导致的，因此没必要转发一个有差错的数据报。通过让发送节点在帧中包括差错检测比特，让接受节点进行差错检查。运输层和网络层提供了有限的差错检测，因特网检验和。链路层的检测更复杂，并且用硬件实现。差错纠正类似于差错检测，接收方不仅能检测帧中出现的比特差错，而且能够准确确定帧中差错出现的位置（并因此纠正这些差错）

链路层实现：链路层主体部分是在网络适配器（网路接口卡，NIC）中实现
位于网络适配器核心的是链路层控制器，通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片。链路控制器的许多功能是用硬件实现的

在发送端，控制器取得了由协议栈较高层生成并存储在主机内存中的数据报，在链路层中封装该数据报（填写该帧的各个字段），然后遵循链路接入协议将该帧传进通信链路中。在接收端，控制器接受了整个帧，抽取出网络层数据报。如果链路层执行差错检测，则需要发送控制器在该帧的首部设置差错检测比特，有接收控制器执行差错检测。

#### 差错检测和纠正技术 

通常要保护的数据

1. 奇偶检验
   - d个数据比特，包含一个附加比特，共b+1个比特
   - 偶校验方案中，选择附加比特的值，使得这d+1个比特中1的总数为偶数。奇校验方案中，则是1的总数为奇数
2. 因特网检验和（checksum）
   - 数据的字节作为16比特的整数对待并求和。这个和的反码形成了携带在报文段首部的因特网检验和。
   - 接收方通过对接收的数据（包括检验和）的和取反码，并且检测其结果是否全为1比特来检测检验和。如果这些比特中有任何比特是0，就可以指示出差错。
3. 循环冗余检测（CRC）
   - 应用最广泛的差错检测技术
   - 给定一个数据段D，发送方选择r个附加比特R，附加到D上，使得到的d+r比特模式（被解释为一个二进制数）用模2算术恰好能被G整除。
   - 用CRC进行差错检测的过程：接收方用G去除接收到的d+r比特，如果余数为非零，出现差错，如果余数为零，数据正确

#### 多路访问链路和协议

点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。
广播链路：多个发送和接收节点都连接到相同的、单一的、共享的广播信道上

多路访问问题：如何协调多个发送方和接收节点对一个共享广播信道的访问

1. 信道划分协议
2. 随机接入协议
3. 轮流协议

#### 交换局域网

##### 链路层寻址和ARP（地址解析协议）

主机和路由器具有链路层地址

###### MAC地址（链路层地址的一种称呼，还有LAN地址、物理地址）

不是主机和路由器具有地址，而是它们的适配器（网络接口）具有链路层地址

MAC地址长度6个字节，共有2**48个可能的地址

IEEE分配给一个公司生产适配器的前2**24，公司自己生成适配器的后24比特地址

IP地址对应于人的邮政地址，可能随着网络接入地点不同而改变，MAC地址对应于身份证，不论到哪都不会改变。

如果想要所有其他适配来接收并处理发送的帧，发送适配器要在该帧的目的地址字段中插入一个特殊的MAC广播地址：FF:FF:FF:FF:FF:FF，

###### ARP（地址解析协议）

因为存在着网络层地址（IP地址）和链路层地址（MAC地址），所以需要在它们之间转换，这就是地址解析协议（ARP）

DNS将主机域名解析为IP地址，ARP将IP地址解析为MAC地址，DNS为互联网任何地方的主机解析主机名，ARP只为在同一个子网上的主机和路由器接口解析IP地址。

工作：

- 每台主机或路由器在其内存中具有一个ARP表，包含IP地址到MAC地址的映射关系，也包含了一个TTL值，指示了从表中删除每个映射的时间
- 发送时，如果ARP表中有的话，就直接发送，没有的话，就发送一个MAC广播的ARP分组，子网中的每个适配器的都会接收到，ARP模块检查自己的IP地址是否与目的IP地址相同，如果相同就返回带有希望映射的ARP分组。然后查询主机更新其ARP表，并发送IP数据报，封装在链路层帧中国，该帧的目的MAC地址就是对先前的ARP请求相应的主机或路由器的MAC地址
- 如果发送数据报到子网之外，首先发送的MAC地址是子网中的路由器的MAC地址，让路由器接收到链路帧再发出去，路由器查询转发表，封装到一个新的帧中，再发送出去

##### 以太网

以太网帧：
前同步码(8字节):目的地址(6字节):源地址(6字节):数据(46~1500字节):CRC(4字节)

- 数据字段：MTU，最大传输单元：1500字节
- 目的地址：MAC地址，6字节
- 源地址：源MAC地址6字节
- 类型字段（2字节）：允许以太网复用多种网络层协议，指定交给那个网络层协议，
- CRC：循环冗余检测，检测帧中是否引入了差错
- 前同步码：前7字节用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。前同步码的第8个字节的最后两个比特（第一次出现两个连续的1）警告适配器“重要的内容就要来了”

##### 链路层交换机

1. 转发和过滤
   - 转发是决定一个帧应该转发到某个接口还是映带将其丢弃的交换机功能
   - 转发是决定一个帧应该被导向哪个接口
2. 自学习
3. 链路层交换机的性质
   - 消除碰撞
   - 异质的链路
   - 管理
4. 交换机和路由器比较







#### 链路虚拟化：网络作为链路层

#### Web页面的请求过程

1. 准备DHCP、UDP、IP和以太网

   - 运行DHCP协议，以从本地DHCP服务器获得一个IP地址及其他信息
   - 生成一个DHCP请求报文，放入具有目的地（服务器）端口67和（DHCP客户）源端口号68的UDP报文段，该报文段被放入具有广播IP目的地之（255.255.255.255）和源IP（0.0.0.0）的IP数据报中，因为目前客户端还不具有一个IP地址
   - 包含DHCP请求报文的IP数据报被放置在以太网帧中，该以太网帧，具有目的MAC地址（FF:FF:FF:FF:FF:FF），该帧将广播到所有与交换机连接的所有设备（包括DHCP服务器）；该帧的源MAC地址就是客户端的MAC地址
   - 包含DHCP请求的广播以太网帧是客户端连入网络中后第一个发送的以太网帧
   - 路由器在接收到该广播以太网帧，该帧中包含DHCP请求，从该以太网帧中取出IP数据报。该数据报的广播IP目的地址指示了整个IP数据报应该在该节点的高层协议处理，因此该数据报的载荷（UDP报文段）被分解向上达到UDP，DHCP请求报文从UDP报文段中抽取出来。此时DHCP服务器有了DHCP请求报文
   - 该路由器根据子网掩码以无类别域间路由选择分配IP地址。DHCP服务器生成含有这个要被分配给客户端的IP地址以及DNS服务器的IP地址、默认网关路由器的IP地址和子网块（网络掩码）的一个DHCP ACK报文，该DCHP报文被放入一个UDP报文段中，然后UDP报文段被放入一个IP数据报中。IP数据报在被放入一个以太网帧中。这个以太网帧的源MAC地址就是路由器连接到归属网络时接口的MAC地址，目的地址就是客户端的MAC地址
   - 包含DHCP ACK报文的以太网帧被发送进入网络，因为交换机是自学习的，并且之前收到了从客户端收到的以太网帧，所以该交换机直到勋执导客户端的MAC地址仅从通向客户端的输出端口转发。
   - 客户端接收到包含DHCP ACK报文的以太网帧，并从该以太网帧中抽取出IP数据报，从IP数据报中抽取出UDP报文段，从UDP报文段中抽取DHCP ACK报文。客户端记录下IP地址和DNS服务器的IP地址，还在IP转发表中安装默认网关的地址。客户端向默认网关发送目的地址为其子网意外的所有数据报

2. DNS和ARP

   - 输入url之后开启了一长串时间
   - 客户端的操作系统生成了一个DNS查询报文，将url放入DNS报文的问题段中，DNS报文则放入具有53号目的端口号的UDP报文段中，UDP报文段被放入具有IP目的地址DNS服务器地址和源IP地址本机地址的IP数据报中。
   - 该IP数据报被放入以太网帧中，以太网帧的源MAC地址就是本机MAC地址，目的MAC地址就是子网路由器的MAC地址。子网路由器的MAC地址通过，前面获取IP时已经知道路由器的IP地址，通过具有路由器IP地址为目的地址的ARP查询报文，该报文被放入具有广播目的MAC地址（FF:FF:FF:FF:FF:FF）的广播帧中。所有子网适配器接收到该以太网广播帧，并将ARP报文中的IP地址与本机的IP地址进行比较，路由器接收到了并且IP地址与本机IP地址一致，就返回具有本路由器MAC地址的ARP回答，该ARP回答被方状态一个以太网帧中，目的地址就客户端的IP地址，被发送给客户端
   - 客户端从ARP回答中抽取出网关路由器的MAC地址。

3. 域内路由选择到DNS服务器

   - 网关路由器接收到前面的包含DNS查询报文的以太网帧，路由器查找该数据报的目的地址，并按转发表转发出去
   - 该DNS查询报文到达了DNS服务器，DNS服务器根据DNS查询报文返回DNS回答报文
   - 最终客户端接收到了DNS回答报文，收到了url的IP地址

4. Web客户端-服务器交互：TCP和HTTP

   - 客户端有了url对应的IP地址，生成与TCP套接字，该套接字用于与url对应的服务器发送HTTP请求

   - 首先客户端与服务器执行三次握手

   - HTTP请求报文封装在具有目的端口号80的TCP报文段中，TCP报文被封装在具有url对应目的IP地址的IP数据报中，该数据报被放入目的MAC地址网关路由器的链路帧中，发送出去

   - 路由器转发

   - 包含HTTP请求的链路帧到达了url服务器，服务器从链路帧中取出IP数据报，从IP数据报中取出TCP报文段，从TCP报文段中取出HTTP请求报文，处理请求，返回HTTP响应报文，封装在对应TCP报文段、IP数据报、链路帧中发送到网络中

   - 最终客户端接收到包含HTTP相应报文的链路帧，解封装提取出HTTP响应报文，从HTTP响应报文中抽取出Web网页的HTML内容，并显示出来

     

### 网络安全

### 无线网络和移动网络

### 多媒体网络

### 网络管理

