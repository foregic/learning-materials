<h1 style="text-align:center;background:;">计算机网络</h1>

> [视频来源：b 站中科大计算机网络](https://www.bilibili.com/video/BV1JV411t7ow)

原理：每一层提供接口供上层使用
实例：网络层-传输层-应用层

可靠 reliable：不出错不重复不丢失不失序

对可靠性要求高：TCP 协议
对可靠性要求不高，对实时性要求高：UDP 协议

检错重传、超时重传、编号、校验、乱序排序占据接收方发送方空间，消耗时间，实时多媒体对时间要求非常高。
网络直播，实时多媒体，事物性应用

远程应用进程，报文交互，应用层协议，主机联网，远程的应用进程之间相互的通讯应该遵守的规则核协议。
浏览器和服务：规范好定义好两者之间交互的语法、语义和时序。

传输层为应用进程提供服务，传输层实在网络层提供的端到端的服务基础上进行实现的。端到端指的主机到主机，网络层提供的源主机到目标主机之间的 IP 数据包。主机到主机要经过好多路由器和交换机。提供的服务是主机到主机的，是尽力而为的，best ever，没有任何保障。IP 层能不能传到，会不会出错，乱不乱序，肯定乱序。
传输层是在网络层提供的服务基础上，主机到主机细分为进程到进程，把 IP 层提供的不可靠的服务通过 TCP 协议变成可靠的服务。
网络层：端到端，包括了若干个点到点，point to point，数字链路层相邻的两点之间的传输服务基础上实现，网卡所提供的数据链路层点到点。物理层：把数字的信号变成物理信号
传输层：end to end

网络层：

- 传统方式：
  - IP 协议，根据到来的路由表，IP 分组，到底往哪走，转发，路由：由路由协议交换路由信息，由路由算法算出路由表，由 IP 协议对到来的分组做转发的处理
  - 路由协议，路由实体与其他路由实体交换报文，路由选择算法，算出路由表，IP 的子网，该怎么走，给 IP 使用
    来了一个 IP 分组，有目标 IP 地址，跟路由算出来的路由表做匹配，判断 IP 落在哪个表项，表项中描述了这个 IP 应该从哪个端口放出去。
    因此 IP 的路由器包括了算出来的路由信息，哪些 IP 的子网该往哪边走。
    查路由表，查到了转发；查不到，按照默认的路径转走。路由器设置好就不会变的。
    缺点：升级，实现新的功能，基本不可能。设计问题，无法添加新功能。
- SDN：软件定义网络，弹性，更加灵活
  - 数据平面：交换机
    流表上载，根据流表描述的行为，动作这个分组
  - 控制平面：网络操作系统
    流表，flow table：目标 IP、源 IP……

###

### 概论:计算机网络和因特网

edge core access
Internet，互联网/网际：实际是由一堆网络构成，通过网络互联设备（路由器）连载一起的网络的网络。
互联网工作是 IP 分组交换工作：网络分组交换必然涉及丢包、分组传输延迟（四大延迟）、吞吐量（性能指标，定义）
一层一层解决，每一层实现一组特定功能，上一层借助下一层提供的服务，通过与对等层协议实体，相互交换协议报文来实现的，目的：为了向上一层提供更好的服务。应用层借助传输层提供的服务，交换应用报文实现各种应用功能。
分层体系架构：
链路层：传输相邻两个节点之间以帧为单位的数据。
网络层：在链路层实现的相邻两点之间传输服务的基础上源主机到目标主机之间的传输。端到端的数据传输。比较粗糙，丢包、出错、失序、错误。尽力而为 IP
传输层：在网络层提供的服务上加强了服务，细分服务，从主机到主机的服务细分成进程到进程，把它从不可靠变成了可靠。TCP/UDP
应用层：按照应用层协议交换应用报文，目的：实现各种各样的网络应用。

网络：节点和边的关系，和大小无关的关系的图
计算机网络：由联网的计算机构成的系统
节点包括主机节点（手机，电脑，冰箱，web 服务器）方的
数据交换节点（路由器交换机），转发数据，既不是源也不是目标 圆的
边也分为两类：主机通过边接入网络，叫接入电路
交换机之间的骨干电路

协议：支持互联网工作的标准
互联网：以 TCP/IP 协议为主一簇协议，由这些协议支撑起的网络就叫互联网

端系统：硬件、操作系统、网络应用
设备本身，操作系统，操作系统驻留的网络应用
host end 方的
switch 路由器 负载均衡设备 圆的

协议就是标准
对等层的实体在通信过程中应该遵守的标准
IETF
协议定了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输和/或接受或其他事件方面所采取的的动作。（语法和语义，时序和动作）
PDU（protocol data unit）
互联网是分布式应用进程，以及为分布式应用进程提供服务的基础设施
socketAPI（网络 API）

面向连接的可靠服务（TCP）和无连接的不可靠服务（UDP）

#### 网络边缘

网络结构：

- 网络边缘 edge
  - 主机
  - 应用程序（客户端和服务器）
- 网络核心 core 所有的边缘节点接在一起
  - 互连着的路由器
  - 网络的网络
  - 数据交换作用
- 接入网、物理媒体：access
  - 有线或者无线通信链路 把边缘接入到核心

网络边缘：

- 端系统
  - 运行应用程序
  - 个人 pc、手机等
- 客户端/服务器
  - 客户端向服务器发送请求
  - 服务器接收请求
  - 可扩展性较差，
  - 到达阈值断崖式下降
  - 可靠性差
- 对等模式 p2p（peer-peer）

  - 没有专门的服务器
  - 每个节点既是客户端也是服务器，通信是分布式的，多用在文件分发系统中
  - 下载文件片段 1 从服务器 1，片段 2 从服务器 2 等等

- 采用网络设施面向连接的服务：
  - TCP
  - 握手：数据传输之前做好准备
  - 可靠，不重复不失序不出错不乱序
  - 可靠地、按顺序传送数据
    - 确认和重传
    - 保序
  - 流量控制
    - 发送方不会淹没接收方
  - 拥塞控制
    - 当网络拥塞时，发送方降低发送速率
- 无连接的服务
  - UDP
    - 无连接
    - 不可靠数据传输
    - 无流量控制
    - 无拥塞控制
  - HTTP（Web）FTP（文件传送）
  - 流媒体、远程会议、DNS、Internet 电话
  - 事务性应用，查询过去结果回来
  - 网络实时多媒体应用

#### 网络核心

网络核心：路由器的网状网络

- 电路交换：预留专有电路
- 分组交换
  - 存储转发
  - 将要传送的数据分成一个个单位，分组
  - 一段一段经由路由器和交换机从源主机传送到目标主机

电路交换：通常用于电话网络
要求建立呼叫连接
专用资源、不共享
保证性能
通信建立时间
网络资源（如贷款）被分成片

- 频分交换节点之间的链路有效频率覆盖范围通过频分划分成若干小片两个主机在通信之间分一片 FDM
- 时分线路使用时间划分成很多个 T，每个 T 划分时间片，分一片 TDM
- 波分波段分成若干个小波段 WDM

电路交换不适合计算机之间通信
连接建立时间长
通信有突发性，浪费的片比较多
不是一直在使用

分组交换：
用就用所有，使用带宽的全部
全部接受存储进来再传给下一个节点 存储转发分为一个个包，完全存下来
按需使用
主机和主机之间的通信分组
换取共享性
耽误存储时间和排队时间
排队延迟
丢失：如果路由器缓存用完了，分组将会被抛弃

网络核心的关键功能：

- 路由：决定分组采用的源到目标的路径
  - 路径算法
- 转发：将分组从路由器的输入链路转移到输出链路

分组交换：

- 统计多路复用
  - 复用链路资源
- 划分时间片不固定
- 分组交换支持的用户数更多，在突发性请求的情况下

| 分组交换                                           | 电路交换                   |
| -------------------------------------------------- | -------------------------- |
| 适用于突发式数据传输，资源共享，简单不建立连接时间 | 资源不共享，要建立呼叫时间 |
| 过度使用会造成网络拥塞：分组延时和丢失`拥塞控制`   | 无分组延时和丢失           |

分组交换网络：存储-转发
分组交换：分组的存储转发一段一段从源主机到目标主机按照有无网络层的连接：分为

- 数据报网络
  - 分组的目标地址决定下一跳
  - 在不同阶段，路由可以改变
  - 类似问路
  - Internet
- 虚电路网络
  - 每个分组都带标签（虚电路表示 VC ID），标签决定下一跳
  - 在呼叫建立时决定路径，在整个呼叫中路径保持不变
  - 路由器维持每个呼叫的状态信息
  - X25 和 ATM

数据报工作原理
不建立连接：有数据就传输
每一个分组都独立路由：路径不一样，可能会失序
根据分组的目标地址进行路由

虚电路
根据虚电路表项存储转发

通信网络

- 电路交换网络
  - FDM
  - TDM
- 分组交换网络
  - 虚电路网络
  - 数据报网络

#### 接入网和物理媒体

住宅接入：modem
上网数据加载到音频信号上
调制和解调
调频、调幅、调相位、综合调制、带宽很窄

接入网（digital subscriber line，DSL）
采用现存的到交换局 DSLAM 的电话线
分上下行

接入网：线缆网络
非对称
有线电视信号线缆双向改造
各用户共享到线缆头端的接入网络

无线接入网络
无线 LAN
广域无线接入

物理媒体
5 类 100M bps
G pbs 千兆以太网
6 类 10G bps 万兆以太网
同轴电缆、光纤
光纤：低误码率两个中继器之间可以有很长的距离，不受电磁噪声干扰、告诉、每个光脉冲表示一个 bit、安全。光缆割开才能获取
传播环境效应：反射、吸收、干扰

#### Internet 结构和 ISP

端系统通过接入 ISP（Internet Service Providers）连接到互联网
互联网络结构：网络的网络

- 竞争
- 合作
  ICP 互联网内容提供商（谷歌、百度等）成本原因；向用户提供高质量服务，减少运营成本。建设全球各地机房，或者租，专线连接，离 ISP 比较近
  DC 数据中心连接若干 local ISP 个各级 ISP 更靠近用户

第一层 ISP（sprint）完成全球范围内覆盖，速率极高，直接与第一层 ISP 相连
与大量第二层 ISP 和其他客户网络相连
第二层 ISP 区域性 region
第三层 ISP 与其他本地 ISP

#### 分组延时、丢失和吞吐量

分组丢失和延时发生原因：

- 分组到达链路的速率超过了链路输出的能力
- 分组等待排到队头、被传输，排队被排满了，后来数据会被丢失

四种分组延时

- 节点处理延时
  - 检查分组情况，检查链路
- 排队延时
  - 在输出链路上等待传输的时间
  - 依赖于路由器的拥塞程度
- 传输延时
  - R=链路带宽（bps）
  - L=分组长度（bits）
  - 将分组发送到链路上的时间=L/R
- 传播延时
  - 每一个 bit 都要传输距离所花时间
  - d=链路长度
  - s=链路上传播速度
  - 传播延时=d/s

信道容量：当传出去第一个 bit 还没到达下一个路由器就已经传完了分组

节点延时
`d_nodal=d_proc+d_queue+d_trans+d_prop`

- d_proc=处理延时 通常微妙数量级
- d_queue=排队延时 却绝于拥塞程度
- d_trans=传输延时 通常为微妙到毫秒
- d_prop=传播延时 几微妙到几百毫秒

R=链路带宽（bps）
L=分组长度（bits）
a 分组达到队列的凭据速率
流量强度=La/R 排队延时与流量强度非线性增长，tan 函数
La/R -> 1 时排队延时会非常大，凭据排队延时将趋向于无穷大

windows **tracert** 提供从源端经过路由器到目标的延时测量
沿着目的路径向每个路由器发送 3 个探测分组 路由器 i 向发送方返回一个分组，发送方对发送和回复之间间隔计时
利用了 ICMP 协议，互联万控制包协议
head IP 头 body IP 数据
分组字段，ip 有一个头部，TTL 字段（head 中）生存时间 TTL 减为 0 就抛掉同时路由器根据 ICMP 协议发送报文给发送端消息告诉发送方分组抛掉
到达目标主机时返送目标端口不可达消息给源主机
从源到目标主机的延迟

分组丢失：

- 链路的队列缓冲容量有限
- 分组到达一个满的队列将会被丢失
- 丢失的分组可能会被前一个节点或源端系统重传，或根本不重传

重传情况

- 源主机重传
  - TCP
- 前一节点重传
  - 如果链路不可靠不重传
- 放弃重传
  - UDP

吞吐量: 在源端和目标端之间传输的速率（数据量/单位时间）

- 瞬间吞吐量: 在一个时间点的速率
- 平均吞吐量: 在一个长时间内平均值
  瓶颈链路：端到端路径上，限制端到端吞吐的链路
  短板效应吞吐量等于各个链路中最小的

#### 协议层次及服务模型

模块化和分层
计算机分层方式：只有相邻两层才能调用

层次化方式实现复杂网络功能:

- 将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：服务
- 本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务
- 在实现本层协议的时候，直接利用了下层所提供的服务
- 本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+更下层所提供的服务

服务( Service)：低层实体向上层实体提供它们之间的通信的能力
原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的---形式
服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—地点；SAP 区分服务用户
PDU（protocol data unit）协议数据单元

通信之前要不要握手，要的话就是面向连接的服务否则就是无连接的服务

服务和协议关系

- 服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直
- 协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平
- 本层协议的实现要靠下层提供的服务来实现
- 本层实体通过协议为上层提供更高级的服务

SAP（service access point）
IDU（interface data unit）
PDU（protocol data unit）协议数据单元
SDU（service data unit）服务数据单元
应用层 PDU：应用报文
传输层 PDU：报文段或者段
网络层 PDU：分组或（IP 数据报）
物理层 PDU：帧
ICI（interface control information）控制信息
SDU 需要加上 ICI 穿过层间接口
拿到 SDU 之后需要加上本次的控制信息，两个加在一起形成了 PDU
SDU 非常大时，分为多个 SDU，每个加上头部形成一个大小合适的 PDU
SDU 非常小时，将若干个 SDU 合在一起形成，加上本层头部形成 PDU
本层头部一部分是 ICI 转变过来的，一部分是本层附加上去的

- 概念化：结构清晰，便于标示网络组件，以及描述其相互关系
  - 分层参考模型
- 结构化：模块化更易于维护和系统升级
  - 改变某一层服务的实现不影响系统中的其他层次
    - 对于其他层次而言是透明的
  - 如改变登机程序并不影响系统的其它部分
    - 改变 2 个秘书使用的通信方式不影响 2 个翻译的工作
    - 改变 2 个翻译使用的语言也不影响上下 2 个层次的工作

Internet 协议栈：

- 应用层：网络应用
  - FTP，SMTP，HTTP，DNS
- 传输层：进程到进程的区分，把 IP 层提供的不可靠的服务变为可靠
  - TCP、UDP
- 网络层：在链路层的服务上，端到端的传输，不可靠
  - IP，路由协议
- 链路层：相邻两点传输以帧为单位的数据
  - 点对点传输协议，以太网、WLAN
- 物理层：在线路上传输 bit，把上层传下来的 frame 帧转换成物理信号，传输，把物理信号转成 frame

ISO/OSI 参考模型
表示层: 允许应用解释传输的数据, e.g., 加密，压缩，机器相关的表示转换
会话层: 数据交换的同步，检查点，恢复

应用层：报文（message）
传输层：报文段（segment）
网络层：分组（packet），无连接数据报（datagram）
链路层：帧（frame）
物理层：位（bit）

发送时一层一层封装，然后收到后一层一层解封

链路交换机：两层解封，装再封装
路由器：三层解封装，再封装

#### 小结

- 组成角度看 什么是互联网
  - 边缘：端系统（包括应用）+接入网
  - 核心：网络交换设备+通信链路
  - 协议：对等层实体通信过程中遵守的规则的集合
    - 语法，语义，时序
- 为了实现复杂的网络功能，采用分层方式设计、实现和调试
- 应用层，传输层，网络层，数据链路层，物理层
- 协议数据单位：
  - 报文，报文段，分组，帧，位
- 从服务角度看互联网
- 通信服务基础设施
  - 提供的通信服务：面向连接 无连接
- 应用
- 应用之间的交互
- C/S 模式
- P2P 模式
- 数据交换
  - 分组数据交换
  - 线路交换
- 比较 线路交换和分组交换
- 分组交换的 2 种方式
  - 虚电路
  - 数据报
- 接入网和物理媒介
  - 接入网技术：
    - 住宅：ADSL，拨号，cable modem
    - 单位：以太网
    - 无线接入方式
  - 物理媒介
    - 光纤，同
- 分组交换网络中延迟和丢失是如何发生的
  - 延迟的组成：处理、传输、传播、排队
- 网络的分层体系结构
  - 分层体系结构
  - 服务
  - 协议数据单元
  - 封装与解封装

### 应用层

#### 2.1 应用层协议原理

网络应用的体系结构

- C/S 模式：C/S：client/server
- 对等模式 peer to peer P2P
  - 任意端系统之间可以通信
  - 每一个接地那既是客户端也是服务器
- 混合体：

进程间通信：

- 同一个主机内，借助操作系统管道、消息队列、共享缓冲区
- 通过交换报文进行通信
  - 借助操作系统提供的通信服务
  - 按照应用协议交换报文

进程间通信问题：

- 进程标识和寻址寻址问题
- 传输层-应用层如何提供服务
  - 位置：SAP（TCP/IP：socket）
  - 形式：API（TCP/IP：socket API）
- 如何使用传输层提供的服务进行应用进程间的报文交换

标识应用进程（end point）
IP
TCP/UDP
端口（TCP 和 UDP 各有 2\*\*16=65536 个端口）

穿过应用层-传输层接口需要：
发的信息 SDU
发给谁：对方的 IP 和端口号
谁传信息:主机 IP，应用进程所使用的端口号

socket API
TCP socket 套接字（）
4 元祖（源 IP，源 port，目标 IP，目标 port）
唯一的指定了一个会话（2 个进程之间的会话关系）
应用使用这个标示，与远程的应用进程通信
不必在每一个报文的发送都要指定这 4 元组
就像使用操作系统打开一个文件，OS 返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名
socket 本地标识
便于管理和穿过层间信息最少
应用层和传输层的约定
TCP socket 用于指定应用进程的本地标示
socket 套接字代表会话关系是一个四元组

UDP socket：只代表本地 IP 本地端口
两个进程之间通信无需建立连接
每个报文都是独立传输，前后报文可能是给不同的分布式进程
UDP socket：本机 IP，本机 port
传输报文时必须提供对方的 IP，port
接收报文时，传输层需要向应用层提供对方的 IP，port
在发送数据报时，采用创建好的本地套接字（标示 ID），就不必在发送每个报文中指明自己所采用的 ip 和 port

应用层协议
定义了：运行在不同端系统上的应用进程如何相互交换报文
应用协议仅仅是应用的一个组成部分

Web 应用：HTTP 协议，web 客户端，web 服务器，HTML

如何描述传输层的服务：

- 数据丢失率
- 吞吐
- 延迟
- 安全性

|     应用     | 数据丢失率 |           吞吐           | 时间敏感性 |
| :----------: | :--------: | :----------------------: | :--------: |
|   文件传输   |  不能丢失  |           弹性           |     不     |
|    email     |  不能丢失  |           弹性           |     不     |
|   web 文档   |  不能丢失  |           弹性           |     不     |
|   实时音频   |  容忍丢失  | 音频：0.5M-1M 视频：0-5M | 是，100ms  |
| 存储音频视频 |  容忍丢失  |           同上           |  是，几秒  |
|  交互式游戏  |  容忍丢失  |         几 K~10K         | 是，100ms  |
|   即时通讯   |  不能丢失  |           弹性           |  是和不是  |

TCP 实体：实现网络协议的软件模块和硬件模块，而且是运行中的软件模块和硬件模块

| TCP 服务                                           | UDP 服务                                                         |
| -------------------------------------------------- | ---------------------------------------------------------------- |
| 可靠地传输服务                                     | 不可靠的数据传输                                                 |
| 流量控制                                           | 不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接 |
| 拥塞控制                                           |                                                                  |
| 不能提供的服务：时间保证、最小吞吐保证和安全       |                                                                  |
| 面向连接：要求在客户端进程和服务器进程之间建立连接 |                                                                  |

UDP 存在的必要性：

- 能够区分不同的进程，IP 服务不能
- 无需建立连接，省去了建立连接的时间，适合事务性的应用
- 不做可靠性的工作，省去了为了可靠性要求的时间代价
- 没有拥塞控制和流量控制，应用能够按照设定的速度发送数据

|     应用      |        应用层层协议         | 下层传输协议 |
| :-----------: | :-------------------------: | :----------: |
|     email     |            SMTP             |     TCP      |
| 远程终端访问  |           Telnet            |     TCP      |
|      Web      |            HTTP             |     TCP      |
|   文件传输    |             FTP             |     TCP      |
|    流媒体     | 专用协议（如 RealNetworks） |  TCP 或 UDP  |
| Internet 电话 |  专用协议（如 Net@Phone）   |  TCP 或 UDP  |

安全性：

- TCP 和 UDP
  - 都没有加密
  - 明文传输
- SSL
  - TCP 基础上实现，应用层服务
  - 私密性
  - 数据完整性
  - 端到端的鉴别
  - 采用 SSL 库，SSL 库使用 TCP 通信

#### 2.2 Web 和 HTTP WWW 万维网(world wide web) HTTP( HyperText Transfer Protocol)

URL 格式：
协议名://用户:口令@主机名/路径名:端口

Web 的应用层协议是超文本传输协议
HTTP：

- 客户端发起一个与服务器的 TCP 连接（建立套接字），端口号 80
  服务器接收客户的 TCP 连接
  在浏览器 HTTP 客户端与 Web 服务器（HTTP server）交换 HTTP 报文
  TCP 连接关闭
  HTTP 是无状态的，服务器不维护关于客户的任何信息
  无状态服务器好处：
- 简单
- 来了连接就服务
- 可以支持更多的客户

HTTP 连接
|非持久 HTTP|持久 HTTP|
|---|---|
|最多只有一个对象在 TCP 连接上发送|多个对象可以在一个 TCP 连接上传输|
|下载多个对象需要多个 TCP 连接|HTTP/1.1 默认使用持久连接|
|HTTP/1.0 使用非持久连接||

非持久连接
连接请求过去，连接请求确认回来
http 请求，http 响应
连接拆除，连接拆除确认

持久连接
连接建立请求，连接建立确认回来
http 请求，http 对象回来
连接不关
如果还有其他请求，仍然在这个连接上发送请求
流水方式和非流水方式
流水方式是 HTTP/1.1 默认方式

往返时间(Round-Trip Time,RTT)：一个短分组从客户到服务器然后再返回客户所话费时间

HTTP 请求报文 ASCII
第一行请求行
请求行

- 方法字段
- URL 字段
- HTTP 版本字段
  首部行
  换行回车符表示报文结束

请求报文

```HTML
GET /somedir/page.html HTTP/1.1 <!--方法行-->
<!-- 首部行-->Host:www.someshcool.edu <!--指明了对象所在的主机-->
<!-- 首部行-->Connection:close<!--告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接-->
<!-- 首部行-->User-agent:Mozilla/5.0<!--知名用户代理，即向服务器发送请求的浏览器的类型-->
<!-- 首部行-->Accept-language:fr<!--表示用户想得到该对象的法语版本，否则服务器应当发送它的默认版本-->
```

请求方式：方法字段
GET:
POST:
HEAD:维护或者索引
PUT:向服务器提交对象
DELETE:用户删除服务器上的对象

HTTP 响应报文

```HTML
HTTP/1.1 200 OK<!--初始状态行-->

Connection:close<!--六个首部行-->
Date:Tue, 09 Aug 2011 15:44:04 GMT
Server:Apache/2.2.3(CentOS)
Last-Modified:Tue, 09 Aug 2011 15:11:03 GMT
Content-Length:6821<!--内容长度/多少字节是内容长度,TCP向上层提供时不分割，传15K*2，TCP提供是30K，需要应用层去区分-->
Content-Type:text/html

(data data data data data data ...)<!--实体体-->
```

一个初始状态行
六个首部行，然后是实体体
实体体是报文的主要部分，即它包含了所请求的对象本身
状态行有三个字段，协议版本字段，状态码和响应状态信息

常见的状态码：

- 200 OK：请求成功
- 301 Moved Permanently：请求的对象已经被永久转移了，新定义的 URL 在响应报文的 Location：首部行中。客户软件将自动获取新的 URL
- 400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解
- 404 Not Found：被请求的文档不在服务器上
- 505 HTTP Version Not Support：服务器不支持请求报文使用的 HTTP 协议版本

用户与服务器的交互：cookie

HTTP是无状态协议，服务器不维护客户端状态，同样的服务器资源可以提供服务给更多的客户端

第一次发送请求没有Cookie，服务器接收到浏览器第一次发送的请求，会给客户端分配一个Cookie同时在服务器本地数据库保留这个Cookie，同时在Response报文头部塞一个Set-cookie，客户端拿到Cookie之后会存到本地文件系统中下次访问时，就会把Cookie带上
Cookie：包括四个部分
- 在Response报文中有一个Cookie的首部行
- 在请求报文中有一个Cookie的首部行
- 在用户端系统中保留一个Cookie文件，由用户的浏览器管理
- 在Web站点有一个后端数据库存储Cookie



Web缓存

Web cache也叫代理服务器

优点：
- 快
- 服务器负载更轻
- 网络负担也减轻





















#### 2.3 FTP                                                                                                                                                                                                                                                                                                                                                                

#### 2.4 SMTP

#### 2.5 DNS



#### 2.6 P2P 应用



#### 2.7 CDN

cdn：内容加速服务

杀手级业务：视频业务

问题：并发问题，规模性；每个节点上下带宽不同，需求不一样，异构问题
解决方案：分布式的、应用层面的基础设施
编码：

- 时间冗余
- 空间冗余



#### 2.8 TCP 套接字（socket）编程

IP地址和port捆绑关系的数据结构
```c++
struct sockaddr_in{
    short sin_family;//AF_INET,地址簇
    u_short sin_port;//port,端口
    struct in_addr sin_addr;//IP address,unsigned long,IP地址
    char sin_zero[8];//align,对齐
}
```

域名和IP地址的数据结构
```c++
struct hostent{
    char *h_name;//主机域名
    char **h_aliases;//主机的一系列别名
    int h_addrtype;//
    int h_length;//地址长度
    char **h_addr_list;//IP地址列表
    #define h_addr h_addr_list[0];//IP[0]代表解析出来后的地址
}
```
#### 2.9 UDP 套接字编程




#### 总结

|||
|---|---|
|HTTP|80|
|FTP|21|
|SMTP|25|
|POP3|110|
|DNS|53|



### 运输层

#### 3.1 概述和传输层服务



#### 3.2 多路复用与分解复用

多路分解就是把在运输层把把运输层报文段中的数据交付给对应的套接字
多路复用就是把不同套接字传来的数据块加上首部信息后生成报文段，然后将报文段传给网络层

#### 3.3 无连接传输: UDP

使用UDP原因：

- 只要传给UDP数据，UDP就会将数据打包进UDP报文段传给网络成发送出去
- 无需建立连接
- 无连连接状态
- 分组首部开销小，TCP报文段20字节首部开销，UDP报文段仅有8字节

UDP报文段结构

UDP提供了数据交付和差错检查功能
差错检查功能是通过检验和实现的，但是对差错恢复无能为力。UDP的实现一是丢弃受损的报文；一是将受损的报文段交给应用程序并给出警告。

#### 3.4 可靠数据传输的原理

GBN协议和SR协议的异同：

- 相同之处
  - 发送窗口大>1
  - 一次能够发送多个未经确认的分组
- 不同之处
  - GBN：接收窗口=1
    - 接收端：只能顺序接收
    - 发送端：从表现上来看一旦一个分组没有发送成功，要返回base重新发送所有已发送但未确认的分组
  - SR：接收窗口>1
    - 接收端：可以乱序接收
    - 一旦有有一分组未成功（丢失或错误）重新发送该分组即可
    - 传递给上层时是顺序传递，发送1，2，3，4，5时，3，4正确，接收端也返回了3，4的ACK，但1，2没有到达或者错误，发送端超时重传，如果正确分组到达的次序是2，1，那么接收端先返回2的ACK，接收1返回1的ACK，此时再按照顺序1，2，3，4，5依个向上层传递分组，进行解封装传递数据工作。

|                        go-back-N，GBN                        | selective Repeat，Sr                         |
| :----------------------------------------------------------: | -------------------------------------------- |
|          发送端最多有在流水线中有N个未经确认的分组           | 发送端最多在流水线中有N个未经确认的分组      |
| 接收端只是发送累计型确认，接收端如果接收到当前等待分组之后的分组，抛弃，不确认 | 接收方对每个到来的分组单独确认               |
|              发送端拥有最老的未确认分组的定时器              | 发送方为每个未确认的分组保持一个定时器       |
|    只需设置一个定时器，当定时器到时时重传所有未确认的分组    | 当定时器到时时，只是重新发送到时的未确认分组 |

|      | GBN                                    | SR                                         |
| ---- | -------------------------------------- | ------------------------------------------ |
| 优点 | 简单，所需资源少（接收方一个缓存单元） | 出错时，重传一个代价小                     |
| 缺点 | 一旦出错，回退N步代价大                | 复杂，所需要资源多，（接收方多个缓存单元） |

适用范围：

- 出错率低：比价适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂的处理
- 链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一旦出错代价太大



#### 3.5 面向连接的传输:TCP

- 点对点：一个发送方，一个接收方
- 可靠地、按顺序的字节流：没有报文边界
- 管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小
- 发送和接收缓存
- 全双工数据：
  - 在同一连接中数据流双向流动
  - MSS（Maximum Segment Size）最大报文段大小：1460B
- 面向连接：在数据交换之前，通过握手（交换控制报文）初始化发送方、接收方的状态变量
- 有流量控制：发送方不会淹没接收方

以太网Maximum Transmission Unit，MTU：1500B
20B TCP头部，20B IP头部，加上最大报文段1460B一共1500B，正好封装在以太网的载荷部，就不存在分片的问题

TCP报文段结构：

![TCP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP报文.png)



![TCP 首部](https://gitee.com/huihut/interview/raw/master/images/TCP首部.png)

序号（32bit）：载荷部分第一个字节在整个报文中的偏移量
确认号（32bit）：期望从临沂房收到的下一个字节的序号

TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：

* URG：紧急比特（urgent），当 `URG＝1` 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。
* ACK：确认比特（Acknowledge）。只有当 `ACK＝1` 时确认号字段才有效，代表这个封包为确认封包。当 `ACK＝0` 时，确认号无效。
* PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
* RST：复位比特(Reset)，当 `RST＝1` 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
* SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
* FIN：终止比特(Final)，用来释放一个连接。当 `FIN＝1` 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

往返时间估计

| 估计 |      |
| ---- | ---- |
| SampleRTT均值EstimatedRTT=(1-α) ×EstimatedRTT+α×SampleRTT | α参考值为0.125 |
| RTT偏差DevRTT=(1-β)×DevRTT+β×\|SampleRTT-EstimatedRTT\| | β推荐值为0.25 |
| 重传超时时间间隔TimeoutInterval=EstimatedRTT+4×DevRTT | 推荐TimeoutInterval初始值为1秒，出现超时后加倍，以免即将被确认的后继报文段过早出现超时。不管怎样，一旦报文段收到并更新EstimatedRTT后，TimeoutInterval将使用公式计算了。 |

流量控制：

- 接收窗口的变量来提供流量控制，指示接收方还有 多少可用的缓存空间
- 主机A通过TCP连接向主机B发送一个大文件
- 主机B为该连接分配了一个接收缓存，并用RcvBuffer来表示其大小
- RcvBuffer大小可以通过socket选项设置
- LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节的编号
- LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节编号
- 由于TCP不允许已分配的缓存溢出所以：`LastByteRcvd-LastByteRead≤RcvBuffer`
- 接收窗口用rwnd表示，根据缓存可用空间的数量来设置：`rwnd=RcvBuffer - [ LastByteRcvd - LastByteRead ]`
- 主机A必须轮流跟踪连个变量，`LastByteSent`和`LastByteAcked`，必须保证：`LastByteSent - LastByteAcked ≤ rwnd`
- 当`rwnd=0`时，由于TCP仅当在它有数据或有确认要发送时才会发送报文段给主机A。这样主机A不可能直到主机B的接收缓存已经有新的空间了，即主机A被阻塞而不能发送数据了
- TCP规范要求：当`rwnd=0`时主机A持续发送只有一个字节数据的报文段，这些报文段将会被接收方确认，最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值

连接管理：

- 第一次：客户端随机选择一个seq=client_isn，与报文段中SYN=1封装在一起发送给服务器端
- 第二次：服务器接收到客户端请求，如果同意建立连接，就随机选择一个seq=server_isn，与报文段中SYN=1，ACK=clinet_isn+1，封装在一起发送给客户端。
- 第三次：客户端接收到服务端返回消息，SYN=0，seq=client_isn+1，ACK=server_isn+1，发送给服务器端。
- 三次握手完毕连接建立，第三次握手可以附带数据。

为什么不两次握手：

- 变化的延迟（连接请求的段没有丢失但可能超时）
- 由于丢失造成的重传（e.g.req_conn(x)）
- 如果两次握手，假如客户端发送的请求延迟到客户端的连接关闭了，此时连接请求到达了服务器端，因为两次握手，所以会建立一个虚假的连接，其后还在网络中的数据请求到达了服务器端，因为已经建立了连接，所以服务器端还是会照常发送数据
- 报文乱序
- 相互看不到对方

两次握手的失败场景：

- 半连接，只在服务器端维护了连接，服务器维持了连接，客户端没有维护
- 老数据被当成新数据接受了

为什么不四次握手？

- 因为服务选择自己的server_ins的时候可以捎带在第二次握手的确认连接中即对第一次SYN=1，seq=client_ins的确认连接的回复SYN=1，ACK=client_ins+1中捎带上seq=server_ins

##### TCP 为什么要进行三次握手？

【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）

> [Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}](https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ)

【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

> [知乎 . TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633/answer/115173386)

【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

> [《计算机网络（第 7 版）-谢希仁》](https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png)

【TCP 释放连接全过程解释】

1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
4. 服务端继续发送之前没发完的数据给客户端；
5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；
7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

TCP连接关闭并不完美
对称释放



##### TCP什么要进行四次挥手

【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？

【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

【答案三】

1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

TCP有限状态自动机

![TCP 的有限状态机](https://gitee.com/huihut/interview/raw/master/images/TCP的有限状态机.png)

#### 3.6 拥塞控制原理

拥塞的原因：

- 分组到达速率超过链路处理速率
- 

拥塞的代价：

- 当分组的到达速率接近链路容量时，分组经历巨大的排队时延
- 发送方必须执行重传以补偿因为缓存溢出而丢弃的分组
- 发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本
- 一个分组沿一条路径被丢弃时，每个上游路由器由于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了

拥塞控制方法：

##### 端到端的拥塞控制

- 没有来自网络的显示反馈
- 端系统根据延迟和丢失时间腿短是否有拥塞
- TCP采取的方法

##### 网络辅助的拥塞控制

- 路由器提供给端系统以返回信息
  - 单个bit置位，显示有拥塞（SNA，DECbit，TCP/IP ECN，ATM）
  - 显式提供发送端可以采用的速率



#### 3.7 TCP拥塞控制

端到端的拥塞控制

TCP拥塞控制机制追踪一个额外的变量，即拥塞窗口（congestion window）`cwnd`，在一个发送方中未被确认的数据量不会唱过`cwnd`与`rwnd`中的最小值，即`LastByteSent-LastByteAcked≤min(cwnd,rwnd)`

TCP发送方如何感知拥塞：
丢包事件：幺妹出现超时，要么收到来自接收方的3个冗余ACK

TCP发送方如何控制发送速率

- 粗略控制
  - 
    
    $$
    rate\approx\frac{CongWin}{RTT}bytes/sec
    $$
    
  - CongWin是动态的，是感知到的网络拥塞成都的函数
    - 超时或者重复超过3个ACK，CongWin下降
      - 超时时，CongWin降为1MSS，进入SS阶然后再倍增到CongWin/2（每个RTT），从而进入CA阶段
      - 3个重复ACK：CongWin降为CongWin/2，CA阶段（拥塞避免阶段）
    - 否则（正常收到ACK，没有出现以上情况）：
      - SS阶段：加倍增加（每个RTT）
      - CA阶段：线性增加（每个RTT）

TCP拥塞控制和流量控制的联合动作：
`SendWin=min(CongWin,RecvWin)`









​    

​    





TCP拥塞控制算法：

- 慢启动
  - 线性增，乘性减少
  - 超时时间后的保守策略
  - 连接刚建立CongWin=1MSS
  - 每当传输的报文段首次被确认就增加1个MSS
  - 每个RTT CongWin翻倍
  - 只要不超时或3个重复的ACK，一个RTT，CongWin加倍
  - 初始速率很慢，但是加速却是指数性的
  - 如何结束这种增长
    - 超时指示的丢包事件（即拥塞）把ssthresh设置为cwnd/2，cwnd设置为1重新开始慢启动过程
    - 当cwnd=ssthresh时，结束慢启动，并且TCP转移到拥塞避免模式，进入拥塞避免模式TCP会更谨慎地增加cwnd
    - 如果检测到3个冗余ACK，这时TCP执行一种快速重传，ssthresh的值变为cwnd的值的一半，cwnd=ssthresh+3MSS，并进入快速恢复状态
- 拥塞避免
  - 一旦进入拥塞避免状态cwnd的值大约为上次遇到拥塞时的值得一半
  - 保守增加每个RTT只将cwnd的值增加一个MSS
  - 出现超时时，cwnd的值被设置为1个MSS，ssthresh的值被更新为cwnd的值得一半
  - 如果收到三个冗余的ACK，ssthresh的值记录为cwnd的值的一半，cwnd变为ssthresh加上三个MSS，进入快速恢复状态
- 快速恢复
  - 对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值增加一个MSS，最终当对丢失报文段的一个ACK到达时，TCP降低cwnd后进入拥塞避免状态
  - 如果出现超时，则ssthresh设置为cwnd的值的一半，cwnd=1MSS进入慢启动阶段
  - 快速恢复是TCP推荐的而非必须的构建。
  - TCP Reno

TCP拥塞控制总结：

- 加性增、乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）

TCP平均吞吐量：
$$
\mit一条连接的的平均吞吐量=\frac{0.75\times{W}}{RTT}，W表示拥塞窗口长度
$$


### 网络层：数据平面

### 网络层：控制平面
### 链路层：链路、接入网和局域网

### 网络安全

### 无线网络和移动网络

### 多媒体网络

### 网络管理
